{"version":3,"sources":["../node_modules/classnames/index.js","vanilla/components/alignment.ts","vanilla/components/counter.ts","vanilla/components/vector1d.ts","vanilla/components/direction.ts","vanilla/components/eventStore.ts","vanilla/components/limit.ts","vanilla/components/dragHandler.ts","vanilla/components/dragTracker.ts","vanilla/components/utils.ts","vanilla/components/scrollBody.ts","vanilla/components/scrollBounds.ts","vanilla/components/scrollContain.ts","vanilla/components/scrollLooper.ts","vanilla/components/scrollProgress.ts","vanilla/components/scrollTarget.ts","vanilla/components/slideLooper.ts","vanilla/components/slideFocus.ts","vanilla/components/translate.ts","vanilla/components/engine.ts","vanilla/components/pxToPercent.ts","vanilla/components/axis.ts","vanilla/components/scrollSnap.ts","vanilla/components/scrollLimit.ts","vanilla/components/animation.ts","vanilla/components/scrollTo.ts","vanilla/components/slidesInView.ts","vanilla/components/options.ts","vanilla/index.ts","vanilla/components/eventEmitter.ts","react/index.ts","react/utils.ts"],"names":["hasOwn","hasOwnProperty","classNames","classes","i","arguments","length","arg","argType","push","Array","isArray","inner","apply","key","call","join","module","exports","default","Alignment","params","viewSize","align","predefined","start","center","end","measure","Number","Counter","limit","loop","min","max","withinLimit","counter","self","add","n","sign","Math","set","get","clone","Vector1D","value","vector","readNumber","divide","multiply","normalize","subtract","Direction","direction","d","v","EventStore","listeners","options","node","removeAll","remove","Limit","reachedMin","reachedMax","constrain","reachedAny","removeOffset","DragHandler","target","scrollBody","dragFree","animation","axis","element","dragTracker","location","events","scrollAxis","scroll","crossAxis","focusNodes","startScroll","startCross","dragStartPoint","activationEvents","interactionEvents","snapForceBoost","mouse","touch","freeForceBoost","baseSpeed","edgeLimit","pointerIsDown","preventScroll","preventClick","isMouse","evt","isMoving","delta","clearPreventClick","isNotFocusNode","name","isFocusNode","preventDefault","addInteractionEvents","up","moveScroll","moveCross","diffScroll","diffCross","diff","reachedLimit","resist","scrollTo","rawForce","force","scrollTarget","index","seekNext","currentLocation","destination","next","edge","allowedForce","factor","forceB","forceA","speedFactor","pointB","addActivationEvents","clickAllowed","pointerDown","removeAllEvents","DragTracker","pxToPercent","coords","x","y","startDrag","diffDrag","lastDrag","pointValue","trackPoints","lastMoveTime","Date","c","point","readPoint","pointerMove","nowTime","diffTime","pointerUp","currentPoint","trackPoint","roundToDecimals","decimalPoints","pow","arrayKeys","array","Object","removeClass","className","cl","addClass","ScrollBody","baseMass","roundToTwoDecimals","velocity","acceleration","attraction","speed","mass","seek","iStart","oStart","magnitude","m","applyForce","settle","hasSettled","update","useBaseMass","useMass","useBaseSpeed","useSpeed","ScrollBounds","disabled","timeout","shouldConstrain","window","constraint","toggleActive","ScrollContain","alignment","contentSize","scrollBounds","alignedWithinView","contentExceedsView","containedSnaps","scrollSnaps","startSnap","endSnap","findDuplicates","ScrollLooper","shouldLoop","loopDistance","vectors","ScrollProgress","scrollLength","ScrollTarget","t1","t2","t3","minDistance","shortest","byDistance","targetSnap","distance","scrollSnap","diffToSnap","shortcut","d1","d2","ascDiffsToSnaps","findTargetSnap","findTargetIndex","reachedBound","snap","byIndex","SlideLooper","scrollLocation","slidesInView","slideSizes","ascItems","descItems","loopPoints","gap","findLoopPoints","slidesInGap","startPoints","endPoints","loopStyle","indexes","a","removeSlideSizes","remainingGap","isStartEdge","offset","slideBounds","initial","altered","b","getTarget","canLoop","clear","slides","loopPoint","SlideFocus","slidesToScroll","root","eventStore","lastTabPressTime","event","selectedIndex","Translate","container","translateAxis","containerStyle","to","getComputedStyle","Engine","viewInPx","startIndex","inViewThreshold","containScroll","cross","width","height","Axis","totalPercent","slideIndexes","snapSizes","size","groups","groupArray","g","alignments","distancesBetween","distancesBetweenScrollSnaps","ScrollSnap","defaultSnaps","contain","shouldContain","trimSnaps","indexPrevious","ScrollLimit","scrollLimit","callback","animationFrame","active","cb","proceed","ifAnimating","stop","Animation","engine","settled","dragHandler","startLocation","loopVectors","indexCurrent","targetDistance","distanceDiff","indexDiff","targetIndex","ScrollTo","threshold","findSlideBounds","loopOffset","thresholds","s","check","slideBound","list","SlidesInView","scrollLooper","scrollProgress","slideFocus","slideLooper","translate","defaultOptions","containerSelector","draggable","draggableClass","draggingClass","selectedClass","EmblaCarousel","destroy","init","reInit","resize","select","emit","e","off","on","EventEmitter","debouncedResize","time","id","debounce","newRootElementSize","rootElementSize","reActivate","activated","Error","nodeList","selector","sliderContainer","sliderRoot","storeElements","deActivate","activate","toggleSelectedClass","setTimeout","inView","slidesNotInView","notInView","newOptions","selectedScrollSnap","type","canScrollNext","canScrollPrev","prev","containerNode","dangerouslyGetEngine","previousScrollSnap","scrollNext","scrollPrev","scrollSnapList","slideNodes","useState","embla","setEmbla","viewport","setViewport","storedOptions","useRef","activeOptions","useMemo","objectA","objectB","objectKey","useEffect","newEmbla_1","Carousel"],"mappings":";6GAAA,OAOC,WACA,aAEA,IAAIA,EAAS,GAAGC,eAEhB,SAASC,IAGR,IAFA,IAAIC,EAAU,GAELC,EAAI,EAAGA,EAAIC,UAAUC,OAAQF,IAAK,CAC1C,IAAIG,EAAMF,UAAUD,GACpB,GAAKG,EAAL,CAEA,IAAIC,SAAiBD,EAErB,GAAgB,WAAZC,GAAoC,WAAZA,EAC3BL,EAAQM,KAAKF,QACP,GAAIG,MAAMC,QAAQJ,IAAQA,EAAID,OAAQ,CAC5C,IAAIM,EAAQV,EAAWW,MAAM,KAAMN,GAC/BK,GACHT,EAAQM,KAAKG,QAER,GAAgB,WAAZJ,EACV,IAAK,IAAIM,KAAOP,EACXP,EAAOe,KAAKR,EAAKO,IAAQP,EAAIO,IAChCX,EAAQM,KAAKK,IAMjB,OAAOX,EAAQa,KAAK,KAGgBC,EAAOC,SAC3ChB,EAAWiB,QAAUjB,EACrBe,EAAOC,QAAUhB,QAGX,kBACL,OAAOA,GADF,QAAe,OAAf,aAtCP,I,qTCIekB,EAAUC,GAChB,IAAAC,EAAoBD,EAApBC,SAAUC,EAAUF,EAApB,MACFG,EAAa,CAAEC,MAErB,WACE,UAH0BC,OAM5B,YACE,OAAOC,KAAP,GAPkCA,IAAG,GAUvC,cACE,OAAOL,EAAP,EAeF,MAHwB,CACtBM,QANF,YACE,wBAAWL,EAJJD,EAAWO,OAAlB,GAKOL,KAAP,K,SChBYM,EAAQT,GACd,IAAAI,EAAuBJ,EAAvBI,MAAOM,EAAgBV,EAAvB,MAAcW,EAASX,EAAvB,KACAY,EAAaF,EAAbE,IAAKC,EAAQH,EAAb,IAEFI,EAAcJ,EADPC,EAAO,OAApB,aAEII,EAAUD,EAAd,GAEA,aACE,SAGF,cAEE,OADAC,EAAUD,EAAVC,GACA,EAgBF,IAAMC,EAAgB,CACpBC,IAdF,cACE,OAAIC,EAAS,CACX,IAAMC,EAAOD,EAAIE,SAAjB,GAEA,OADAC,EAAIC,IAAJD,GACOJ,EAAIC,GAAX,EAAeC,GAEjB,UASAI,MANF,WACE,OAAOd,EAAQ,CAAEL,MAAOkB,IAAOZ,MAAhB,EAAuBC,KAAI,KAM1CW,IAHoB,EAIpBT,IAJoB,EAKpBD,IALoB,EAMpBS,IAAG,GAEL,S,SC5CcG,EAASC,GACvB,IAAIC,EAAJ,EA0BA,cAEE,OADAA,KACA,EAQF,cACE,MAAoB,kBAANR,EAAiBA,EAAIA,EAAnC,MAGF,IAAMF,EAAiB,CACrBC,IA9BF,YAEE,OADAS,GAAUC,EAAVD,GACA,GA6BAE,OAFqB,EAGrBN,IAzCF,WACE,UAyCAO,SAvBF,YAEE,OADAH,KACA,GAsBAI,UAdF,WAEE,OADA,IAAIJ,GAAcE,KAClB,GAaAP,IAxCF,YAEE,OADAK,EAASC,EAATD,GACA,GAuCAK,SA/BF,YAEE,OADAL,GAAUC,EAAVD,GACA,IA+BF,S,SCrDcM,EAAUP,GACxB,IAAMQ,EAAYT,EAASM,EAA3B,IAGA,cACE,OAAOZ,QAAcA,EAAIE,SAAzB,GASF,IAAMJ,EAAkB,CACtBM,IAbcW,EAARX,IAcND,IARF,YACE,IAAMa,EAAIJ,EAAUK,EAApB,OAEA,OADA,IAAID,GAASD,SACb,IAOF,S,SCXcG,IACd,IAAIC,EAAJ,GAoBA,IAAMrB,EAAmB,CACvBC,IAnBF,kBAUE,YANA,IAAAqB,OAAA,GAEAC,0BACAF,QAAe,WACb,OAAOE,0BAAP,MAEF,GAUAC,UAPF,WAEE,OADAH,EAAYA,EAAA,QAAiB,SAAAI,GAAU,OAAAA,OACvC,IAOF,S,SCtBcC,EAAM1C,GACZ,IAAAY,EAAaZ,EAAbY,IAAKC,EAAQb,EAAb,IACFf,EAASmC,SAASR,EAAxB,GAEA,cACE,OAAOM,EAAP,EAGF,cACE,OAAOA,EAAP,EAGF,cACE,OAAOyB,MAAiBC,EAAxB,GA+BF,MAXoB,CAClBC,UANF,YACE,OAAKC,EAAL,GACOH,OAAP,EAD2BzB,GAM3BjC,OAFkB,EAGlB0B,KAbF,YACE,OAAKmC,EAAL,GACOH,OAAP,EAD2BzB,GAa3BL,IAJkB,EAKlBD,IALkB,EAMlBkC,WANkB,EAOlBF,WAPkB,EAQlBD,WARkB,EASlBI,aA1BF,YACE,GAAInC,IAAJ,EAAiB,OAAOM,EACxB,KAAOyB,EAAP,IAAsBzB,KACtB,KAAO0B,EAAP,IAAsB1B,KACtB,W,SCAY8B,EAAYhD,GAClB,IAAAiD,EAAkDjD,EAAlDiD,OAAQC,EAA0ClD,EAAlD,WAAoBmD,EAA8BnD,EAAlD,SAA8BoD,EAAoBpD,EAAlD,UAAyCqD,EAASrD,EAAlD,KACAsD,EAAkDtD,EAAlDsD,QAASC,EAAyCvD,EAAlD,YAAsBwD,EAA4BxD,EAAlD,SAAgCyD,EAAkBzD,EAAlD,OAAwCU,EAAUV,EAAlD,MACQ0D,EAAiCL,EAAzCM,OAA2BC,EAAcP,EAAzC,MACFQ,EAAa,CAAC,QAAS,SAA7B,YACMC,EAActC,EAApB,GACMuC,EAAavC,EAAnB,GACMwC,EAAiBxC,EAAvB,GACMyC,EAAmB7B,IACnB8B,EAAoB9B,IACpB+B,EAAiB,CAAEC,MAAF,IAAcC,MAAO,KACtCC,EAAiB,CAAEF,MAAF,EAAYC,MAAO,GACpCE,EAAYpB,EAAW,EAA7B,GAEMqB,EAAY9B,EAAM,CACtB9B,IAAKF,MADiB,GAEtBG,IAAKH,MAAY,KAGf+D,GAAJ,EACIC,GAAJ,EACIC,GAAJ,EACIC,GAAJ,EAgEA,cAEE,KADAA,gBAAUC,SACV,IAAgBA,SAAhB,CAEA,IAAMC,EAAWC,EAAM9B,EAAD,MAAeO,EAApBuB,QAAjB,EACMC,EAAoBJ,IAA1B,EACMK,GA1CR,YACE,IAAMC,EAAO3C,YAAb,GACA,OAAOsB,cAAP,EAwCwBsB,CAAYN,EAApC,QACMO,EAAiBN,GAAaF,GAApC,EAEAH,KACAlB,iBACAS,SACAf,SACAC,6BA/DF,WACE,IAAMX,EAAQqC,EAAd,SAAwBtB,EACxBY,mFA8DAmB,GACAvB,MAAgBP,cAAhBO,IACAC,MAAeR,cAAfQ,IACAN,sBAEA,IAAuBkB,MACvB,GAAoBE,oBAGtB,cACE,IAAKH,IAAL,EAAgC,CAC9B,IAAKG,EAAL,WAAqB,OAAOS,IAC5B,IAAMC,EAAahC,iBAAnB,MACMiC,EAAYjC,iBAAlB,MACMkC,EAAaV,EAAMQ,EAAYzB,EAArC,OACM4B,EAAYX,EAAMS,EAAWzB,EAAnC,OAEA,KADAW,EAAgBe,EAAhBf,KACA,EAAqC,OAAOY,IAE9C,IAAMK,EAAOpC,cAAb,GACMqC,EAAelF,aAAiB8C,EAAtC,OACMqC,GAAU7F,EAAD,UAAf,GAEK2E,GAAL,IAA2BA,MAC3BvB,UACAH,MAAW0C,EAAX1C,GACA4B,mBAGF,aACU,IAAAiB,EAAa9F,EAAb8F,SACFC,EAAWxC,eA3EHJ,EAAWmB,EAAzB,GACaM,EAAU,QAAvB,SA2EMoB,EAhER,YACU,IAAAC,EAAwBjG,EAAxBiG,aAAcC,EAAUlG,EAAxB,MAGFmG,IAFkBF,gBAAxB,GACsBG,QAA0BF,EAAhD,QACmC9E,YA3DrC,EA4DQiF,EAAcL,EAAQxC,EAA5B,MAEA,GAAI2C,QAA0BzF,aAA9B,GAA6D,CAC3D,IAAM4F,EAAOJ,eAAb,EAA+BlE,YAC/B,OAAOiE,UAAqBK,EAArBL,SAAP,SAEF,IAAKjG,EAAD,MAAgBwE,aAApB,GAAuD,CACrD,IAAM+B,EAAO/B,sBAAb,MACA,OAAOA,KAAkBvB,EAAzB,MAEF,OAAOgD,mBAAP,SAiDcO,CAAd,GACMC,EAxER,cACE,IAAMd,EAAOZ,EAAM3D,SAAD,GAAmBA,SAArC,IACA,OAAIA,aAAoBA,SAAxB,IACIsF,OAAJ,IAAoBC,EAD6B,EAE1CvF,SAASuE,EAAhB,GAoEeiB,CAAYb,EAA3B,GACiBhB,EAAM9B,EAAD,MAAee,EAApBe,QAAjB,KAEA,IAA0BJ,MAC1BD,KACAD,KACAP,cACAhB,WAAoBqB,EAAYA,EAAhCrB,GACA4C,iBACAlB,KACAnB,oBAGF,gBACE,OAAOrC,SAASyF,EAAhB,GAGF,cACE,GAAkBhC,mBAiBpB,MAN0B,CACxBiC,oBA3IF,WACE,IAAMvE,EAAN,EACA0B,qBAC0B,eAD1BA,kBAEyB,eAFzBA,2GA0IA8C,aAVF,WACE,UAUAC,YAPF,WACE,UAOAC,gBAzHF,WACEhD,cACAC,gB,SCpEYgD,EAAYlH,GAClB,IAAAqD,EAAsBrD,EAAtBqD,KAAM8D,EAAgBnH,EAAtB,YACQ0D,EAAeL,EAAvBM,OACFyD,EAAS,CAAEC,EAAF,UAAgBC,EAAG,WAC5BC,EAAY/F,EAAlB,GACMgG,EAAWhG,EAAjB,GACMiG,EAAWjG,EAAjB,GACMkG,EAAalG,EAAnB,GAIImG,EAAJ,GACIC,GAAe,IAAIC,MAAvB,UACIjD,GAAJ,EAEA,gBACEA,GAAWC,EAAXD,QACA,IAAMkD,EAAIV,EAAV,GACM3F,EAAQmD,EAAUC,EAAH,GAAYA,aAAjCiD,GACA,OAAOJ,MAAP,GA+CF,MAN0B,CACxBV,YAvCF,YACE,IAAMe,EAAQC,EAAUnD,EAAxB,GAGA,OAFA0C,SACAE,SACON,UAAoBI,EAA3B,QAoCAU,YAjCF,YACE,IAAMF,EAAQC,EAAUnD,EAAxB,GACMqD,GAAU,IAAIL,MAApB,UACMM,EAAWD,EAAjB,EAUA,OARIC,GA1BN,KA2BQA,GAzBR,MAyB+BR,MAC3BA,OAAiBI,EAAjBJ,OACAC,KAGFJ,qBACAC,SACON,UAAoBK,EAA3B,QAqBAY,UAlBF,WACE,IACMD,GADU,IAAIN,MAApB,UACA,EACMQ,EAAeZ,EAArB,MAEMzB,EAAQ2B,EAAA,OAzChB,GAyCgB,KAEP,SAAAW,GAAc,OAAAD,EAAA,KAFP,MAGN,cAAY,OAACjH,YAAeA,SAAfA,MAAD,KAHpB,GAOA,OAFAqG,MAAaU,EA7Cf,MA6CeA,IAAbV,GACAE,KACOR,UAAoBM,EAA3B,QAOAO,UAAS,G,SC1DGO,EAAgBC,GAC9B,IAAMC,EAAMrH,YAAZ,GACA,OAAO,YAAe,OAAAA,KAAA,MAAWF,EAAX,M,SAcRwH,EAAuBC,GACrC,OAAOC,mBAAP,Q,SAGcC,EAAYtG,EAAmBuG,GAC7C,IAAMC,EAAKxG,EAAX,UACIuG,GAAaC,WAAjB,IAAyCA,Y,SAG3BC,EAASzG,EAAmBuG,GAC1C,IAAMC,EAAKxG,EAAX,UACIuG,IAAcC,WAAlB,IAA0CA,S,SC5B5BE,EAAWjJ,GACjB,IAAAwD,EAA+CxD,EAA/CwD,SAAiBe,EAA8BvE,EAA/C,MAAkCkJ,EAAalJ,EAA/C,KACFmJ,EAAqBZ,EAA3B,GACMa,EAAW5H,EAAjB,GACM6H,EAAe7H,EAArB,GACM8H,EAAa9H,EAAnB,GACMS,EAAYD,EAAlB,GACIuH,EAAJ,EACIC,EAAJ,EAkCA,cAEE,OADAD,IACA,EAGF,cAEE,OADAC,IACA,EAWF,IAAMxI,EAAmB,CACvBiB,UADuB,EAEvBwH,KAzCF,YACEH,qBACA,ID1CFI,EAEAC,ECwCQC,EAAYN,EAAlB,MACMO,GDzCRF,ECyCmC,IAAnBC,GD3ChBF,EC2C2B,KAAG,IDtC9B,ICsCE,EDtCc,GC6Cd,OANAzH,SACAqH,sCAVF,YACEnH,YACAkH,SAYAS,IACA,GAgCAC,OA7BF,YACE,IAAMpE,EAAOxD,QAAUqB,EAAvB,MAEMwG,GADcb,EAApB,GAGA,OADA,GAAgB3F,SAChB,GAyBAyG,OAtDF,WACEb,SACA5F,SACA6F,eAoDAa,YATF,WACE,OAAOC,EAAP,IASAC,aAdF,WACE,OAAOC,EAAP,IAcAF,QAPuB,EAQvBE,SAAQ,GAEV,S,SC1EcC,EAAatK,GACnB,IAAAU,EAA2CV,EAA3CU,MAAO8C,EAAoCxD,EAA3C,SAAiBkD,EAA0BlD,EAA3C,WAA6BoD,EAAcpD,EAA3C,UACAY,EAAqCF,EAArCE,IAAKC,EAAgCH,EAArC,IAAUiC,EAA2BjC,EAArC,WAAsBkC,EAAelC,EAArC,WAEJ6J,GAAJ,EACIC,EAAJ,EA6BA,MAJ2B,CACzB3H,UAjBF,aAPA,YACE,OAAI0H,IAAJ,IACI5H,EAAWa,EAAf,OAAuCrB,UAAP,IAC5BS,EAAWY,EAAf,QAAuCrB,UAAP,IAK3BsI,CAAL,KAEAD,EAAUE,OAAA,YAAkB,WAC1B,IAAMC,EAAajK,YAAgByB,EAAnC,OACAA,SACAe,0BACAE,UACAoH,MAnBJ,MA6BEI,aANF,YACEL,O,SC7BYM,EAAc7K,GACpB,IAAA8K,EAAqC9K,EAArC8K,UAAWC,EAA0B/K,EAArC,YAAwBC,EAAaD,EAArC,SACFgL,EAAetI,EAAM,CAAE9B,KAAMmK,EAAR,EAAgClK,IAAK,IAC1DoK,EAAoB,CAACH,UAA3B,IACMI,EAAqBH,EAA3B,EAsBA,MAH4B,CAC1BxK,QAVF,cACE,IAAM4K,EAAiBC,MAAgBJ,EAAvC,WACM,EAVR,YACE,IAAMK,EAAYD,EAAlB,GACME,EAAUF,EAAYA,SAA5B,GAGA,OAAO1I,EAAM,CAAE9B,IAFHwK,iBAAZ,EAEoBvK,IADRuK,UAAZ,KAMqBG,CAAf,GAAE3K,EAAG,EAAL,IAAOC,EAAG,EAAV,IAEN,SACA,EACOsK,QAAqBvK,EAArBuK,EAA8BtK,EAArC,GADkBsK,EADcF,I,SClBpBO,EAAaxL,GACnB,IAAA+K,EAA8C/K,EAA9C+K,YAAavH,EAAiCxD,EAA9C,SAAuBU,EAAuBV,EAA9C,MAA8BmH,EAAgBnH,EAA9C,YAGF,EAA6B0C,EAAM,CAAE9B,IAF/BF,MAAYyG,UAAxB,IAEgDtG,IADpCH,MAAYyG,UAAxB,MACQxE,EAAU,EAAZ,WAAcC,EAAU,EAAxB,WAkBN,MAH2B,CACzBjC,KARF,cACE,GAPF,YACE,WAAIsB,EAAwBW,EAAWY,EAAlB,QACrB,IAAIvB,GAAyBU,EAAWa,EAAlB,OAKjBiI,CAAL,IAEA,IAAMC,EAAeX,IAArB,EAAoC9I,GACpC0J,WAAgB,SAAAxJ,GAAK,OAAAA,EAAA,a,SCrBTyJ,EAAe5L,GACvB,MAAgCA,EAAhC,MAAEa,EAAG,EAAL,IAAegL,EAAY,EAA3B,OAUN,MAH6B,CAC3BvK,IANF,YAEE,OADwBJ,EAAxB,IACA,I,SCSY4K,EAAa9L,GACnB,IAAAW,EAA0CX,EAA1CW,KAAMD,EAAoCV,EAA1C,MAAaoL,EAA6BpL,EAA1C,YAA0B+K,EAAgB/K,EAA1C,YACA4C,EAAyClC,EAAzCkC,WAAYE,EAA6BpC,EAAzC,WAAwBqC,EAAiBrC,EAAzC,aAER,gBACE,OAAOU,YAAeA,SAAfA,KAAP,EAeF,gBACE,IAAM2K,EAAN,EACMC,EAAK/I,EAAX,EACMgJ,EAAKhJ,EAAX,EAEA,MAAW,OAAO8I,EAClB,MAAgB,OAAOG,EAAYA,EAAYH,EAAb,GAAlB,GAEhB,IAAMI,EAAWD,EAAYH,EAAI9J,QAAjC,GACA,OAAOb,YAAP,EAoCF,MAL2B,CACzBgL,WAfF,cACE,IAAMnJ,EAASjD,eAAf,EACMqM,EAxCR,YACE,IAAMC,EAAWvJ,EAAjB,GAQA,MAAO,CAAEmD,MAPekF,EAAA,KACjB,SAAAmB,GAAc,OAAAA,EAAA,KADG,KAEjB,SAAAC,GAAc,OAAAC,EAASD,EAAT,MAFG,KAGjB,cAAa,MAAC,CAAE7G,KAAF,EAAQO,MAAOnH,MAHZ,MAIhB,cAAY,OAAAqC,KAAA,IAASsL,EAAT,MAAoBtL,SAASuL,EAA7B,SAEFC,GAAV1G,MACQoG,SAAQ,GA+BLO,CAAnB,GACM3G,EAjBR,cAEE,MADsBvF,GAAQmC,EAA9B,IACmB,OAAOoD,EAEpB,MAAelG,EAAf,MAAEY,EAAG,EAAL,IAAOC,EAAG,EAAV,IACN,OAAO+B,OAAP,EAYckK,CAAgB7J,EAAQoJ,EAAtC,OACMU,GAAgBpM,GAAQmC,EAA9B,GAEA,OAAKkK,GAAL,EAAkC,CAAE9G,MAAF,EAASoG,SAAQ,GAK5C,CAAEpG,MAAF,EAASoG,SAFKA,EAAWG,EADbrB,KAAqBiB,EAAxC,SACA,KAOAY,QAtBF,cAGE,MAAO,CAAE/G,MAAF,EAASoG,SADCG,EADErB,KAAqBpL,SAAxC,MACA,KAqBAyM,SAAQ,G,SCxDIS,EAAYlN,GAClB,IAAAqD,EAAiDrD,EAAjDqD,KAAgB8J,EAAiCnN,EAAjD,SAAgCoN,EAAiBpN,EAAjD,aACA+K,EAAmD/K,EAAnD+K,YAAa9K,EAAsCD,EAAnD,SAAuBqN,EAA4BrN,EAAnD,WAAmCoL,EAAgBpL,EAAnD,YACFsN,EAAW5E,EAAjB,GACM6E,EAAY7E,KAAlB,UACM8E,EAgCN,WACE,IAAMC,EAAMrC,KAAZ,EAEA,OAAOsC,EADSC,EAAYJ,EAA5B,GACA,OAnCiBK,UAsCnB,WACE,IAAMH,EAAMxN,EAAWmL,EAAXnL,GAAZ,EAEA,OAAOyN,EADSC,EAAYL,EAA5B,GACA,SAzCsCO,IAClCC,EAAYzK,sBAAlB,MAEA,gBACE,OAAO0K,EAAA,QAAe,cACpB,OAAOC,EAAIX,EAAX,KADF,GAKF,gBACE,OAAOU,EAAA,QAAe,cAEpB,OADqBE,EAAiBD,EAAtC,GACOE,EAAmBF,SAAS,CAA5BE,IAAP,IAFF,IAMF,gBACE,IAAMC,EAAN,UAAoB5H,EACd6H,EAASD,GAAW,EAA1B,EACME,EAAcjB,kBAApB,GAEA,OAAOW,EAAA,KAAY,SAAA7H,GACjB,IAAMoI,EAAUH,EAAc,GAA9B,EACMI,EAAUJ,EAAcpD,EAA9B,EAEMhD,EADSsG,EAAA,QAAmB,SAAAG,GAAK,OAAAA,EAAA,aAAvC,GACqBL,EAAc,MAAnC,SAGA,MAAO,CAAEpG,MAAF,EAAS0G,UAFE,WAChB,OAAAtB,EAAA,aACyBjH,MAApB,EAA2B1C,UAAW,MA8CjD,MAN0B,CACxBkL,QAzBF,WACE,OAAOlB,EAAA,OAAiB,Y,IAAGtH,EAAK,QAE9B,OAAO+H,EADcX,EAAA,QAAgB,SAAAvO,GAAK,OAAAA,IAAA,KACnCkP,IAAP,MAuBFU,MARF,YACEnB,WAAmB,Y,IAAGtH,EAAK,QACzB0I,qBAOFjO,KApBF,YACE6M,WAAmB,SAAAqB,GACT,IAAAJ,EAA+BI,EAA/BJ,UAAWjL,EAAoBqL,EAA/B,SAAqB3I,EAAU2I,EAA/B,MACF5L,EAASwL,IACXxL,IAAJ,IACE2L,cAAoC3L,EAApC2L,IACAC,kBAeJrB,WAAU,G,SC9FEsB,EAAW9O,GACjB,IAAA8F,EAAmC9F,EAAnC8F,SAAUiJ,EAAyB/O,EAAnC,eAA0BgP,EAAShP,EAAnC,KACFiP,EAAa7M,IACb6E,EAAkBgI,EAAxB,UACIC,EAAJ,EAEA,cACE,IAAKC,YACLD,GAAmB,IAAIrH,MAAvBqH,WAGF,gBAUED,iBATc,WAGZ,MAFgB,IAAIpH,MAApB,UACA,EACA,KAEAmH,eACA,IAAMI,EAAgBhO,WAAW8E,EAAjC,GACAJ,iBAEFmJ,GAYF,MAJyB,CACvBnI,oBANF,YACEmI,+BACAL,cAKA3H,gBAAe,G,SC9BHoI,EAAUrP,GAChB,IAAAqD,EAAoBrD,EAApBqD,KAAMiM,EAActP,EAApB,UAEFuP,EADa,CAAElI,EAOrB,YACE,MAAO,iBAAP,cARsBC,EAWxB,YACE,MAAO,qBAAP,WAX+BjE,EAAjC,QACM8F,EAAqBZ,EAA3B,GACMiH,EAAiBF,EAAvB,MACI/E,GAAJ,EACI/G,EAAJ,EAmCA,MALwB,CACtBmL,MANF,WACEa,eACAhM,KAKAiM,GAtBF,YACE,OACA,IAAMxM,EAASkG,EAAmBhH,EAAlC,OAEIqB,IAAJ,IACEkM,8BACAF,YAA2BD,EAA3BC,GACAhM,OAgBFoH,aAZF,YACEL,O,SCOYoF,EACdX,EACAM,EACAV,EACAtM,EACAmB,GAIE,ICvDwBmM,EDuDxB1P,EASEoC,EATFpC,MACMwD,EAQJpB,EATF,KAEAuN,EAOEvN,EATF,WAGAwN,EAMExN,EATF,gBAIA3B,EAKE2B,EATF,KAKAiH,EAIEjH,EATF,MAMAa,EAGEb,EATF,SAOAyM,EAEEzM,EATF,eAQAyN,EACEzN,EATF,cAYIe,E,SEhEaA,GACnB,IAAMM,EAASN,YAAf,IAaA,MALmB,CACjB2M,MARY3M,YAAd,IASE9C,QAPF,YACQ,MAAoBgC,EAApB,wBAAE0N,EAAK,EAAP,MAASC,EAAM,EAAf,OACN,MAAOvM,UAAP,GAMAA,OAAM,GFoDKwM,CAAb,GACMhJ,GCpEoByI,EDoEMvM,UAAhC,GC7D0B,CACxB9C,QALF,YACE,OAAQW,EAAD,EAHT,KAQEkP,aARF,MDoEMnQ,EAAWkH,EAAjB,aACMkG,EAAauB,MAAWvL,EAAXuL,aAA6BzH,EAAhD,SACMkJ,EAAe3H,EAArB,GAEM4H,E,SVlDN3H,EACA4H,GAGA,IADA,IAAMC,EAAN,GACSzR,EAAT,EAAgBA,EAAI4J,EAApB,OAAkC5J,GAAlC,EACEyR,OAAY7H,UAAe5J,EAA3ByR,IAEF,SU0CqBC,CAAWpD,EAAhC,GACkB,KAAiB,SAAAqD,GAAK,OAAAA,EAAA,QAAS,cAAU,OAAA1C,EAAA,QACrDjD,EAAcsC,EAAA,QAAkB,cAAU,OAAAW,EAAA,IAAhD,GACMlD,EAAY/K,EAAU,CAAEG,MAAF,EAASD,SAAQ,IACvCsM,E,SGnEmBvM,GACjB,IAAAsQ,EAA+BtQ,EAA/BsQ,UAAWxF,EAAoB9K,EAA/B,UAAsBW,EAASX,EAA/B,KACF2Q,EAAaL,MAAcxF,EAAjC,SACM8F,EAEN,WACE,IACM7P,EAAUN,EAAQ,CAAEC,MADZgC,EAAM,CAAE9B,IAAF,EAAUC,IAAKyP,SAAmB,IACrBlQ,MAAT,EAAmBO,KAAI,IAE/C,OAAO2P,EAAA,KAAc,cACnB,IAAMhK,EAAOvF,MAAYmF,EAAZnF,GAAb,MACA,OAAOwP,EAAOI,EAAPJ,GAA2BI,EAAlC,MARqBE,GAoBzB,MAHyB,CACvBtQ,QANF,YAEE,OADcqQ,UAAd,GACO,QAAa,cAAU,OAAA5C,EAAA,IAAO2C,EAArC,MHkDiBG,CAAW,CAAER,UAAF,EAAaxF,UAAb,EAAwBnK,KAAI,IACpDoQ,EAAerI,SAAyB6D,EAA9C,SACMyE,EAAUnG,EAAc,CAAEC,UAAF,EAAaC,YAAb,EAA0B9K,SAAQ,IAC1DgR,GAAiBtQ,GAAvB,KAA+BoP,EACzBmB,EAAN,cAAkBnB,EACZ5E,EAAiB6F,YAAvB,GACM5F,EAAc6F,EAAgB9F,EAApC,EAKMjF,EAAQzF,EAAQ,CAAEC,MADNgC,EAAM,CAAE9B,IAAF,EAAUC,IADjBO,WAAYgK,SAA7B,KAE0ChL,MAApB,EAAuCO,KAAI,IAC3DwQ,EAAgBjL,EAAtB,QAIMxF,E,SItFoBV,GAClB,IAAA+K,EAAsB/K,EAAtB+K,YAAapK,EAASX,EAAtB,KAaR,MAH0B,CACxBO,QATF,YACE,IAAM8K,EAAYD,EAAlB,GACME,EAAUF,EAAYA,SAA5B,GAGA,OAAO1I,EAAM,CAAE9B,IAFHD,EAAO0K,EAAH,EAAhB,EAEoBxK,IADpB,MJ8EkBuQ,CAAY,CAAEzQ,KAAF,EAAQoK,YAAW,IACrCsG,QAAd,GA0BMjO,E,SKnHkBkO,GACxB,IAAIC,EAAJ,EAEA,gBACE,OAAO,WACDC,MAAJ,GAAiCC,KAIrC,aACEF,EAAiB7G,6BAAjB6G,GAaF,MALwB,CACtBG,QAASC,GAAY,EADC,GAEtBvR,MAAOuR,GAAY,EAFG,GAGtBC,KAAMD,GAAY,GARpB,WACEjH,+BACA6G,QLoGgBM,EAvBH,WACbC,+BACA,IAAMC,EAAUD,qBAAhB,GASA,GAPKE,GAAL,gBACE,GAAWF,6BACX,IACEA,oBACArO,mBAGJ,EAAU,CACR,IAAMxB,EAAY6P,wBAAlB,MACAA,0BACAA,uBAGF,GAAcrO,iBACdqO,mBACAA,0BAKIG,EAAgB7G,EAAYlF,EAAlC,OACM1C,EAAWhC,EAAjB,GACMyB,EAASzB,EAAf,GACM0Q,EAAc,CAAC1O,EAArB,GACMN,GAAa+F,EAAW,CAC5BzF,SAD4B,EAE5B+F,MAF4B,EAG5BC,KAAM,IAEFvD,GAAe6F,EAAa,CAChCf,YADgC,EAEhC7E,MAFgC,EAGhCxF,MAHgC,EAIhCC,KAJgC,EAKhCyK,YALgC,EAMhCnI,OAAM,IAEF6C,G,SMzHiB9F,GACf,IAAOmS,EAA0CnS,EAAjDkG,MAAqBD,EAA4BjG,EAAjD,aAAmCoD,EAAcpD,EAAjD,UACAmR,EAAkDnR,EAAlDmR,cAAe1N,EAAmCzD,EAAlD,OAA+BoS,EAAmBpS,EAAlD,OAER,cACE,IAAMqS,EAAepP,EAArB,SACMqP,EAAYrP,UAAiBkP,EAAnC,MAEA,IACE/O,UACAgP,UAEF,IACEjB,MAAkBgB,EAAlBhB,OACAgB,MAAiBlP,EAAjBkP,OACA1O,kBAmBJ,MAJuB,CACrB6I,SAZF,cAEExG,EADeG,eAAf,KAYAC,MARF,cACE,IAAMqM,EAAcJ,cAApB,GAEArM,EADeG,UAAqBsM,EAArBtM,MAAf,MN+FeuM,CAAS,CACxBpP,UADwB,EAExBK,OAFwB,EAGxByC,MAHwB,EAIxBiL,cAJwB,EAKxBlL,aALwB,GAMxBhD,OAAM,IAEFmK,G,SOhIqBpN,GACnB,IAAA+K,EAAsC/K,EAAtC+K,YAAasC,EAAyBrN,EAAtC,WAAyBC,EAAaD,EAAtC,SACA8P,EAA0B9P,EAA1B8P,gBAAiBnP,EAASX,EAA1B,KACFyS,EAAYrR,SAASA,WAATA,KAAlB,KACMgK,EAAc1C,UAMpB,YAEE,OADa2E,UAAb,GACO,QAAY,cAAU,OAAAW,EAAA,IAA7B,MANIK,GADU1N,EAAO,CAAC,EAAGoK,GAAP,GAAoC,CAAxD,IACoB,QAAe,cACjC,OAAOiD,SAAS0E,EAAgBC,EAAhC,MADF,IASA,gBACE,IAAMC,EAAavF,EAAA,KAAe,SAAAwF,GAAK,OAAAA,GAAKJ,GAAL,MACvC,OAAOrH,EAAA,KAAgB,cAAiB,MAAC,CACvChL,MAAO4M,EAAOK,EAAPL,GAA2B4F,EAA3B5F,GADgC,EAEvC1M,IAAK0M,IAAkB4F,EAAlB5F,GAFkC,EAGvC9G,MAAK,MAiBT,MAJ2B,CACzB4M,MAVF,YACE,OAAOzE,EAAA,QAAmB,cAChB,IAAAnI,EAAsB6M,EAAtB7M,MAAO9F,EAAe2S,EAAtB,MAAczS,EAAQyS,EAAtB,IAGR,SAFA,IAAeC,gBACA5S,KAAoBE,EAAnC,GAC2B0S,SAAY,CAAhC,IAAP,IAJF,KAUAN,gBAAe,GP6FIO,CAAa,CAChClI,YADgC,EAEhC+E,gBAFgC,EAGhCnP,KAHgC,EAIhC0M,WAJgC,EAKhCpN,SAAQ,IAIJ+R,GAAchP,EAAY,CAC9BI,UAD8B,EAE9BC,KAF8B,EAG9BF,SAH8B,EAI9BI,YAAa2D,EAAY,CACvB7D,KADuB,EAEvB8D,YAAW,IAEb7D,QAR8B,EAS9BG,OAT8B,EAU9ByC,MAV8B,EAW9BxF,MAX8B,EAY9B8C,SAZ8B,EAa9B7C,KAb8B,EAc9BuC,WAd8B,GAe9B4C,SAf8B,GAgB9BG,aAhB8B,GAiB9BhD,OAAM,IAIF6O,GAAiB,CACrB1O,UADqB,EAErBC,KAFqB,EAGrB2O,YAHqB,GAIrB7K,YAJqB,EAKrBjB,MALqB,EAMrBiL,cANqB,EAOrBzQ,MAPqB,EAQrB8C,SARqB,EASrBlB,QATqB,EAUrBY,WAVqB,GAWrB8H,aAAcV,EAAa,CACzBlH,UADyB,EAEzB1C,MAFyB,EAGzB8C,SAHyB,EAIzBN,WAAU,KAEZgQ,aAAc1H,EAAa,CACzBT,YADyB,EAEzBrK,MAFyB,EAGzB8C,SAHyB,EAIzB2D,YAAW,IAEbgM,eAAgBvH,EAAe,CAC7BlL,MAAK,IAEP0K,YA1BqB,EA2BrBnF,aA3BqB,GA4BrBH,SA5BqB,GA6BrBsN,WAAYtE,EAAW,CACrBE,KADqB,EAErBlJ,SAFqB,GAGrBiJ,eAAc,IAEhBsE,YAAanG,EAAY,CACvB7J,KADuB,EAEvB0H,YAFuB,EAGvBvH,SAHuB,EAIvB4H,YAJuB,EAKvBiC,WALuB,EAMvBD,aANuB,GAOvBnN,SAAQ,IAEVmN,aA3CqB,GA4CrBiD,aA5CqB,EA6CrBpN,OA7CqB,EA8CrBqQ,UAAWjE,EAAU,CACnBhM,KADmB,EAEnBiM,UAAS,KAGb,UQjNK,IAAMiE,EAA0B,CACrCrT,MADqC,SAErCmD,KAFqC,IAGrC0M,cAHqC,GAIrCyD,kBAJqC,IAKrCrQ,UALqC,EAMrCsQ,WANqC,EAOrCC,eAPqC,eAQrCC,cARqC,cASrC7D,gBATqC,EAUrCnP,MAVqC,EAWrCiT,cAXqC,cAYrC7E,eAZqC,EAarCxF,MAbqC,GAcrCsG,WAAY,GCFd,SAASgE,EAAc,EAAvB,GAIE,IAMA,EAIA,EACA,EAXMpQ,E,WChBN,IAAMpB,EAAuB,CAC3ByR,QAD2B,GAE3B9M,YAF2B,GAG3BoB,UAH2B,GAI3B2L,KAJ2B,GAK3BC,OAL2B,GAM3BC,OAN2B,GAO3BtQ,OAP2B,GAQ3BuQ,OAR2B,GAS3BnK,OAAQ,IAkBJ/I,EAAqB,CACzBmT,KAhBF,YAEE,OADA9R,cAAuB,SAAA+R,GAAK,OAAAA,EAAA,MAC5B,GAeAC,IAPF,cAEE,OADAhS,KAAiBA,EAAA,WAAsB,SAAA+R,GAAK,OAAAA,IAAA,KAC5C,GAMAE,GAbF,cAEE,OADAjS,KAAiBA,YAAsB,CAAvCA,IACA,IAaF,SDhBekS,GACTtF,EAAa7M,IACboS,E,SnBzBiBlD,EAAsBmD,GAC7C,IAAMjK,EAAU,CAAEkK,GAAI,GACtB,OAAO,WACLhK,oBAAoBF,EAApBE,IACAF,KAAaE,wBAAbF,GmBqBsBmK,EA+GxB,WACE,MAAgB,OAChB,IAAMC,EAAqB9C,eAA3B,GACI+C,IAAJ,GAA4CC,IAC5CrR,mBAnHF,KACMuQ,EAAN,EACQM,EAAY7Q,EAAZ6Q,GAAID,EAAQ5Q,EAAZ,IAGJsR,GAAJ,EACIzS,EAAU,KAAd,GACIuS,EAAJ,EAMA,aACE,MAAiB,MAAM,IAAIG,MAAV,kCAEjB,InB7CgCC,EmB6C1BC,EAAW5S,EAAjB,kBACM6S,EAAkBC,gBAAxB,GAEA,MAAsB,MAAM,IAAIJ,MAAV,uCnBhDUC,GmBkDhC3F,KACAV,WnBlDKvP,2BAAP,GmBqDA,cAQE,GAPAgW,IACA/S,EAAU,IAAVA,GACAwP,EAASnC,EAAOyF,EAAY9F,EAAWV,EAAQtM,EAA/CwP,GACA+C,EAAkB/C,eAAlB+C,GACA5F,yBACA6C,eAAoBA,EAApBA,UAEIxP,EAAJ,KAAkB,CAChB,IAAKwP,cAAL,UAEE,OADAwD,IACOC,EAAS,CAAE5U,MAAM,IAE1BmR,sBAEExP,aAAqBsM,EAAzB,SACEkD,oCACIxP,EAAJ,gBACE0G,EAASoM,EAAY9S,EAArB0G,gBAEE1G,EAAJ,eACEmB,yCAKAmL,EAAJ,QACEkD,oCAEExP,EAAJ,gBACEkT,IACA/R,oCAIF,IACEgS,YAAW,WAAM,OAAAhS,EAAA,eAAjBgS,GACAV,MAIJ,cACU,IAAApB,EAAkBrR,EAAlBqR,cACR,gBAAI9O,EAAuBmE,EAASoM,EAApC,GACKvM,EAAYuM,EAAZvM,GAGP,aACU,IAAA+K,EAAkBtR,EAAlBsR,cACF8B,EAAStI,GAAf,GACkBuI,GAAlB,GACAC,SAAkB,SAAA7W,GAAK,OAAA8J,EAAY+F,EAAD,GAAX,MACvB8G,WAAe,SAAA3W,GAAK,OAAAiK,EAAS4F,EAAD,GAAR,MAGtB,aACEkD,gCACAA,+BACAA,mBACA7C,cACA6C,oBACAA,uBACAjJ,EAAYuM,EAAY9S,EAAxBuG,gBACA+F,WAAe,SAAAiE,GAAK,OAAAhK,EAAYgK,EAAGvQ,EAAf,kBACpBmB,kBACAA,qBACAA,uBACAA,qBAGF,cACE,MACA,IACMoS,EAAa,EAAc,CAAEhG,WADhBiG,KACnB,GACAR,IACAC,KACA9R,kBAiBF,cACE,IAAMD,EAAWsO,EAAO7O,EAAS,SAAhB6O,YAAjB,MACMiE,EAAOzT,sBAAb,YACA,OAAOwP,qBAA0BA,WAAjC,IAGF,cACE,IAAM4D,EAAStI,EAAf,GACA,OAAO0E,EAAA,qBAA2B,SAAA/S,GAAK,WAAA2W,EAAA,QAAA3W,MAGzC,gBACE+S,0CACA,GAAeA,mBAA6B7P,GAA7B6P,GA+BjB,aACE,OAAOA,QAAP,MA4CF,OApMAyD,KA+K4B,CAC1BS,cA3CF,WAEE,OADalE,oBAAb,GACOxL,QAAewP,KA0CtBG,cAvCF,WAEE,OADanE,qBAAb,GACOoE,QAAeJ,KAsCtB/O,aAnBF,WACE,OAAO+K,cAAP,gBAmBAqE,cAZF,WACE,UAYAC,qBAjBF,WACE,UAiBAtC,QAxFF,WACE,IACAwB,IACAP,KACAtR,oBAqFA4Q,IAP0B,EAQ1BC,GAR0B,EAS1B+B,mBA7BF,WACE,OAAOvE,gBAAP,OA6BAkC,OAV0B,EAW1BsC,WA/DF,WAEExQ,EADagM,oBAAb,GACQ,OAARhM,IA8DAyQ,WA3DF,WAEEzQ,EADagM,qBAAb,GACQ,MAARhM,IA0DAqN,eAzCF,WACE,OAAOrB,qBAA0BA,WAAjC,QAyCA0E,eA9CF,WACE,OAAO1E,kBAAuBA,iBAA9B,MA8CAhM,SAf0B,EAgB1BgQ,mBAhB0B,EAiB1BW,WArBF,WACE,UAqBArJ,aAlB0B,EAmB1BuI,gBAAe,G,mBEzOnB,SAA0BrT,QAAA,IAAAA,MAAA,IAClB,MAAoBoU,EAApB,WAACC,EAAK,EAAN,GAAQC,EAAQ,EAAhB,GACA,EAA0BF,EAA1B,WAACG,EAAQ,EAAT,GAAWC,EAAW,EAAtB,GACAC,EAAgBC,SAAtB,GACMC,EAAgBC,WAAsB,W,ICN5CC,EACAC,EDSE,OCVFD,EDOuBJ,EAAD,QCNtBK,EDME,ECHAxO,wBAAgCA,eAAhCA,QACAA,OAAA,eAA2B,SAAAyO,GACzB,QAAKD,iBAAL,IACOD,OAAuBC,EAA9B,QDCAL,aAEKA,EAAP,UACC,CAACA,EALJ,IAiBA,OAVAO,aAAU,WACR,GCrBkB,qBAAX5M,QACPA,OADA,UAEAA,gBAHF,eDsBE,EAA6B,CAC3B,IAAM6M,EAAWC,EAASX,EAA1B,GAEA,OADAD,KACO,WAAM,oBAEbA,YAED,CAACC,EAAUI,EARdK,IAUO,CAACR,EAAR","file":"static/js/6.824f8b54.chunk.js","sourcesContent":["/*!\n  Copyright (c) 2017 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames () {\n\t\tvar classes = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg;\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses.push(arg);\n\t\t\t} else if (Array.isArray(arg) && arg.length) {\n\t\t\t\tvar inner = classNames.apply(null, arg);\n\t\t\t\tif (inner) {\n\t\t\t\t\tclasses.push(inner);\n\t\t\t\t}\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tfor (var key in arg) {\n\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\tclasses.push(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.join(' ');\n\t}\n\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\tdefine('classnames', [], function () {\n\t\t\treturn classNames;\n\t\t});\n\t} else {\n\t\twindow.classNames = classNames;\n\t}\n}());\n","export type AlignmentOption = 'start' | 'center' | 'end' | number\n\ntype Params = {\n  viewSize: number\n  align: AlignmentOption\n}\n\nexport type Alignment = {\n  measure: (n: number) => number\n}\n\nexport function Alignment(params: Params): Alignment {\n  const { viewSize, align } = params\n  const predefined = { start, center, end }\n\n  function start(): number {\n    return 0\n  }\n\n  function center(n: number): number {\n    return end(n) / 2\n  }\n\n  function end(n: number): number {\n    return viewSize - n\n  }\n\n  function percent(): number {\n    return viewSize * Number(align)\n  }\n\n  function measure(n: number): number {\n    if (typeof align === 'number') return percent()\n    return predefined[align](n)\n  }\n\n  const self: Alignment = {\n    measure,\n  }\n  return self\n}\n","import { Limit } from './limit'\n\ntype Params = {\n  start: number\n  limit: Limit\n  loop: boolean\n}\n\nexport type Counter = {\n  min: number\n  max: number\n  get: () => number\n  set: (n: number) => Counter\n  add: (n: number) => Counter\n  clone: () => Counter\n}\n\nexport function Counter(params: Params): Counter {\n  const { start, limit, loop } = params\n  const { min, max } = limit\n  const type = loop ? 'loop' : 'constrain'\n  const withinLimit = limit[type]\n  let counter = withinLimit(start)\n\n  function get(): number {\n    return counter\n  }\n\n  function set(n: number): Counter {\n    counter = withinLimit(n)\n    return self\n  }\n\n  function add(n: number): Counter {\n    if (n !== 0) {\n      const sign = n / Math.abs(n)\n      set(get() + sign)\n      return add(n + sign * -1)\n    }\n    return self\n  }\n\n  function clone(): Counter {\n    return Counter({ start: get(), limit, loop })\n  }\n\n  const self: Counter = {\n    add,\n    clone,\n    get,\n    max,\n    min,\n    set,\n  }\n  return self\n}\n","export type Vector1D = {\n  get: () => number\n  set: (v: Vector1D | number) => Vector1D\n  add: (v: Vector1D | number) => Vector1D\n  subtract: (v: Vector1D | number) => Vector1D\n  multiply: (n: number) => Vector1D\n  divide: (n: number) => Vector1D\n  normalize: () => Vector1D\n}\n\nexport function Vector1D(value: number): Vector1D {\n  let vector = value\n\n  function get(): number {\n    return vector\n  }\n\n  function set(n: Vector1D | number): Vector1D {\n    vector = readNumber(n)\n    return self\n  }\n\n  function add(n: Vector1D | number): Vector1D {\n    vector += readNumber(n)\n    return self\n  }\n\n  function subtract(n: Vector1D | number): Vector1D {\n    vector -= readNumber(n)\n    return self\n  }\n\n  function multiply(n: number): Vector1D {\n    vector *= n\n    return self\n  }\n\n  function divide(n: number): Vector1D {\n    vector /= n\n    return self\n  }\n\n  function normalize(): Vector1D {\n    if (vector !== 0) divide(vector)\n    return self\n  }\n\n  function readNumber(n: Vector1D | number): number {\n    return typeof n === 'number' ? n : n.get()\n  }\n\n  const self: Vector1D = {\n    add,\n    divide,\n    get,\n    multiply,\n    normalize,\n    set,\n    subtract,\n  }\n  return self\n}\n","import { Vector1D } from './vector1d'\n\nexport type Direction = {\n  get: () => number\n  set: (v: Vector1D) => Direction\n}\n\nexport function Direction(value: number): Direction {\n  const direction = Vector1D(normalize(value))\n  const { get } = direction\n\n  function normalize(n: number): number {\n    return n === 0 ? 0 : n / Math.abs(n)\n  }\n\n  function set(v: Vector1D): Direction {\n    const d = normalize(v.get())\n    if (d !== 0) direction.set(d)\n    return self\n  }\n\n  const self: Direction = {\n    get,\n    set,\n  }\n  return self\n}\n","type EventRemover = () => void\ntype EventHandler = EventListener | EventListenerObject | null\ntype EventOptions = boolean | AddEventListenerOptions | undefined\n\nexport type EventStore = {\n  add: (\n    node: EventTarget,\n    type: string,\n    handler: EventHandler,\n    options?: EventOptions,\n  ) => EventStore\n  removeAll: () => EventStore\n}\n\nexport function EventStore(): EventStore {\n  let listeners: EventRemover[] = []\n\n  function add(\n    node: EventTarget,\n    type: string,\n    handler: EventHandler,\n    options: EventOptions = false,\n  ): EventStore {\n    node.addEventListener(type, handler, options)\n    listeners.push(() => {\n      return node.removeEventListener(type, handler, options)\n    })\n    return self\n  }\n\n  function removeAll(): EventStore {\n    listeners = listeners.filter(remove => remove())\n    return self\n  }\n\n  const self: EventStore = {\n    add,\n    removeAll,\n  }\n  return self\n}\n","type Params = {\n  min: number\n  max: number\n}\n\nexport type Limit = {\n  min: number\n  max: number\n  length: number\n  loop: (n: number) => number\n  constrain: (n: number) => number\n  reachedAny: (n: number) => boolean\n  reachedMax: (n: number) => boolean\n  reachedMin: (n: number) => boolean\n  removeOffset: (n: number) => number\n}\n\nexport function Limit(params: Params): Limit {\n  const { min, max } = params\n  const length = Math.abs(min - max)\n\n  function reachedMin(n: number): boolean {\n    return n < min\n  }\n\n  function reachedMax(n: number): boolean {\n    return n > max\n  }\n\n  function reachedAny(n: number): boolean {\n    return reachedMin(n) || reachedMax(n)\n  }\n\n  function removeOffset(n: number): number {\n    if (min === max) return n\n    while (reachedMin(n)) n += length\n    while (reachedMax(n)) n -= length\n    return n\n  }\n\n  function loop(n: number): number {\n    if (!reachedAny(n)) return n\n    return reachedMin(n) ? max : min\n  }\n\n  function constrain(n: number): number {\n    if (!reachedAny(n)) return n\n    return reachedMin(n) ? min : max\n  }\n\n  const self: Limit = {\n    constrain,\n    length,\n    loop,\n    max,\n    min,\n    reachedAny,\n    reachedMax,\n    reachedMin,\n    removeOffset,\n  }\n  return self\n}\n","import { Animation } from './animation'\nimport { Counter } from './counter'\nimport { Direction } from './direction'\nimport { DragTracker } from './dragTracker'\nimport { EventEmitter } from './eventEmitter'\nimport { Axis } from './axis'\nimport { EventStore } from './eventStore'\nimport { Limit } from './limit'\nimport { ScrollBody } from './scrollBody'\nimport { ScrollTarget } from './scrollTarget'\nimport { ScrollTo } from './scrollTo'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  axis: Axis\n  element: HTMLElement\n  target: Vector1D\n  dragFree: boolean\n  dragTracker: DragTracker\n  location: Vector1D\n  animation: Animation\n  scrollTo: ScrollTo\n  scrollBody: ScrollBody\n  scrollTarget: ScrollTarget\n  index: Counter\n  limit: Limit\n  loop: boolean\n  events: EventEmitter\n}\n\nexport type DragHandler = {\n  addActivationEvents: () => void\n  clickAllowed: () => boolean\n  pointerDown: () => boolean\n  removeAllEvents: () => void\n}\n\nexport function DragHandler(params: Params): DragHandler {\n  const { target, scrollBody, dragFree, animation, axis } = params\n  const { element, dragTracker, location, events, limit } = params\n  const { scroll: scrollAxis, cross: crossAxis } = axis\n  const focusNodes = ['INPUT', 'SELECT', 'TEXTAREA']\n  const startScroll = Vector1D(0)\n  const startCross = Vector1D(0)\n  const dragStartPoint = Vector1D(0)\n  const activationEvents = EventStore()\n  const interactionEvents = EventStore()\n  const snapForceBoost = { mouse: 2.5, touch: 3.5 }\n  const freeForceBoost = { mouse: 5, touch: 7 }\n  const baseSpeed = dragFree ? 5 : 12\n  const dragThreshold = 4\n  const edgeLimit = Limit({\n    min: limit.min - 70,\n    max: limit.max + 70,\n  })\n\n  let pointerIsDown = false\n  let preventScroll = false\n  let preventClick = false\n  let isMouse = false\n\n  function addActivationEvents(): void {\n    const node = element\n    activationEvents\n      .add(node, 'touchmove', () => undefined)\n      .add(node, 'touchend', () => undefined)\n      .add(node, 'touchstart', down)\n      .add(node, 'mousedown', down)\n      .add(node, 'touchcancel', up)\n      .add(node, 'contextmenu', up)\n      .add(node, 'click', click)\n  }\n\n  function addInteractionEvents(): void {\n    const node = !isMouse ? element : document\n    interactionEvents\n      .add(node, 'touchmove', move)\n      .add(node, 'touchend', up)\n      .add(node, 'mousemove', move)\n      .add(node, 'mouseup', up)\n  }\n\n  function removeAllEvents(): void {\n    activationEvents.removeAll()\n    interactionEvents.removeAll()\n  }\n\n  function isFocusNode(node: Element): boolean {\n    const name = node.nodeName || ''\n    return focusNodes.indexOf(name) > -1\n  }\n\n  function forceBoost(): number {\n    const boost = dragFree ? freeForceBoost : snapForceBoost\n    const type = isMouse ? 'mouse' : 'touch'\n    return boost[type]\n  }\n\n  function speedFactor(forceB: number, forceA: number): number {\n    const diff = delta(Math.abs(forceB), Math.abs(forceA))\n    if (Math.abs(forceB) <= Math.abs(forceA)) return 0\n    if (forceB === 0 || forceA === 0) return 0\n    return Math.abs(diff / forceB)\n  }\n\n  function allowedForce(force: number): number {\n    const { scrollTarget, index } = params\n    const currentLocation = scrollTarget.byDistance(0, false)\n    const targetChanged = currentLocation.index !== index.get()\n    const seekNext = !targetChanged && Math.abs(force) > dragThreshold\n    const destination = force + location.get()\n\n    if (seekNext && !dragFree && !limit.reachedAny(destination)) {\n      const next = index.clone().add(Direction(force).get() * -1)\n      return scrollTarget.byIndex(next.get(), 0).distance\n    }\n    if (!params.loop && edgeLimit.reachedAny(destination)) {\n      const edge = edgeLimit.reachedMax(destination) ? 'max' : 'min'\n      return edgeLimit[edge] - target.get()\n    }\n    return scrollTarget.byDistance(force, !dragFree).distance\n  }\n\n  function down(evt: Event): void {\n    isMouse = evt.type === 'mousedown'\n    if (isMouse && (evt as MouseEvent).button !== 0) return\n\n    const isMoving = delta(target.get(), location.get()) >= 2\n    const clearPreventClick = isMouse || !isMoving\n    const isNotFocusNode = !isFocusNode(evt.target as Element)\n    const preventDefault = isMoving || (isMouse && isNotFocusNode)\n\n    pointerIsDown = true\n    dragTracker.pointerDown(evt)\n    dragStartPoint.set(target)\n    target.set(location)\n    scrollBody.useBaseMass().useSpeed(80)\n    addInteractionEvents()\n    startScroll.set(dragTracker.readPoint(evt, scrollAxis))\n    startCross.set(dragTracker.readPoint(evt, crossAxis))\n    events.emit('pointerDown')\n\n    if (clearPreventClick) preventClick = false\n    if (preventDefault) evt.preventDefault()\n  }\n\n  function move(evt: Event): void {\n    if (!preventScroll && !isMouse) {\n      if (!evt.cancelable) return up()\n      const moveScroll = dragTracker.readPoint(evt, scrollAxis).get()\n      const moveCross = dragTracker.readPoint(evt, crossAxis).get()\n      const diffScroll = delta(moveScroll, startScroll.get())\n      const diffCross = delta(moveCross, startCross.get())\n      preventScroll = diffScroll > diffCross\n      if (!preventScroll && !preventClick) return up()\n    }\n    const diff = dragTracker.pointerMove(evt)\n    const reachedLimit = limit.reachedAny(location.get())\n    const resist = !params.loop && reachedLimit ? 2 : 1\n\n    if (!preventClick && diff) preventClick = true\n    animation.start()\n    target.add(diff / resist)\n    evt.preventDefault()\n  }\n\n  function up(): void {\n    const { scrollTo } = params\n    const rawForce = dragTracker.pointerUp() * forceBoost()\n    const force = allowedForce(rawForce)\n    const factor = speedFactor(rawForce, force)\n    const isMoving = delta(target.get(), dragStartPoint.get()) >= 0.5\n\n    if (isMoving && !isMouse) preventClick = true\n    preventScroll = false\n    pointerIsDown = false\n    interactionEvents.removeAll()\n    scrollBody.useSpeed(baseSpeed + baseSpeed * factor)\n    scrollTo.distance(force, !dragFree)\n    isMouse = false\n    events.emit('pointerUp')\n  }\n\n  function delta(pointB: number, pointA: number): number {\n    return Math.abs(pointB - pointA)\n  }\n\n  function click(evt: Event): void {\n    if (preventClick) evt.preventDefault()\n  }\n\n  function clickAllowed(): boolean {\n    return !preventClick\n  }\n\n  function pointerDown(): boolean {\n    return pointerIsDown\n  }\n\n  const self: DragHandler = {\n    addActivationEvents,\n    clickAllowed,\n    pointerDown,\n    removeAllEvents,\n  }\n  return self\n}\n","import { Axis, AxisOption } from './axis'\nimport { PxToPercent } from './pxToPercent'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  axis: Axis\n  pxToPercent: PxToPercent\n}\n\nexport type DragTracker = {\n  pointerDown: (evt: Event) => number\n  pointerMove: (evt: Event) => number\n  pointerUp: () => number\n  readPoint: (evt: any, axis: AxisOption) => Vector1D\n}\n\nexport function DragTracker(params: Params): DragTracker {\n  const { axis, pxToPercent } = params\n  const { scroll: scrollAxis } = axis\n  const coords = { x: 'clientX', y: 'clientY' }\n  const startDrag = Vector1D(0)\n  const diffDrag = Vector1D(0)\n  const lastDrag = Vector1D(0)\n  const pointValue = Vector1D(0)\n  const trackInterval = 10\n  const trackLength = 5\n  const trackTime = 100\n  let trackPoints: number[] = []\n  let lastMoveTime = new Date().getTime()\n  let isMouse = false\n\n  function readPoint(evt: any, type: AxisOption): Vector1D {\n    isMouse = !evt.touches\n    const c = coords[type]\n    const value = isMouse ? evt[c] : evt.touches[0][c]\n    return pointValue.set(value)\n  }\n\n  function pointerDown(evt: Event): number {\n    const point = readPoint(evt, scrollAxis)\n    startDrag.set(point)\n    lastDrag.set(point)\n    return pxToPercent.measure(startDrag.get())\n  }\n\n  function pointerMove(evt: Event): number {\n    const point = readPoint(evt, scrollAxis)\n    const nowTime = new Date().getTime()\n    const diffTime = nowTime - lastMoveTime\n\n    if (diffTime >= trackInterval) {\n      if (diffTime >= trackTime) trackPoints = []\n      trackPoints.push(point.get())\n      lastMoveTime = nowTime\n    }\n\n    diffDrag.set(point).subtract(lastDrag)\n    lastDrag.set(point)\n    return pxToPercent.measure(diffDrag.get())\n  }\n\n  function pointerUp(): number {\n    const nowTime = new Date().getTime()\n    const diffTime = nowTime - lastMoveTime\n    const currentPoint = lastDrag.get()\n\n    const force = trackPoints\n      .slice(-trackLength)\n      .map(trackPoint => currentPoint - trackPoint)\n      .sort((p1, p2) => (Math.abs(p1) < Math.abs(p2) ? 1 : -1))[0]\n\n    lastDrag.set(diffTime > trackTime || !force ? 0 : force)\n    trackPoints = []\n    return pxToPercent.measure(lastDrag.get())\n  }\n\n  const self: DragTracker = {\n    pointerDown,\n    pointerMove,\n    pointerUp,\n    readPoint,\n  }\n  return self\n}\n","export function map(\n  value: number,\n  iStart: number,\n  iStop: number,\n  oStart: number,\n  oStop: number,\n): number {\n  return oStart + (oStop - oStart) * ((value - iStart) / (iStop - iStart))\n}\n\nexport function arrayFromCollection(nodeList: HTMLCollection): HTMLElement[] {\n  return Array.prototype.slice.call(nodeList)\n}\n\nexport function debounce(callback: () => void, time: number): () => void {\n  const timeout = { id: 0 }\n  return (): void => {\n    window.clearTimeout(timeout.id)\n    timeout.id = window.setTimeout(callback, time) || 0\n  }\n}\n\nexport function roundToDecimals(decimalPoints: number): (n: number) => number {\n  const pow = Math.pow(10, decimalPoints)\n  return (n: number) => Math.round(n * pow) / pow\n}\n\nexport function groupArray<GenericType>(\n  array: GenericType[],\n  size: number,\n): GenericType[][] {\n  const groups = []\n  for (let i = 0; i < array.length; i += size) {\n    groups.push(array.slice(i, i + size))\n  }\n  return groups\n}\n\nexport function arrayKeys<GenericType>(array: GenericType): number[] {\n  return Object.keys(array).map(Number)\n}\n\nexport function removeClass(node: HTMLElement, className: string): void {\n  const cl = node.classList\n  if (className && cl.contains(className)) cl.remove(className)\n}\n\nexport function addClass(node: HTMLElement, className: string): void {\n  const cl = node.classList\n  if (className && !cl.contains(className)) cl.add(className)\n}\n","import { Direction } from './direction'\nimport { map, roundToDecimals } from './utils'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  location: Vector1D\n  speed: number\n  mass: number\n}\n\nexport type ScrollBody = {\n  direction: Direction\n  seek: (v: Vector1D) => ScrollBody\n  settle: (v: Vector1D) => boolean\n  update: () => void\n  useBaseMass: () => ScrollBody\n  useBaseSpeed: () => ScrollBody\n  useMass: (n: number) => ScrollBody\n  useSpeed: (n: number) => ScrollBody\n}\n\nexport function ScrollBody(params: Params): ScrollBody {\n  const { location, speed: baseSpeed, mass: baseMass } = params\n  const roundToTwoDecimals = roundToDecimals(2)\n  const velocity = Vector1D(0)\n  const acceleration = Vector1D(0)\n  const attraction = Vector1D(0)\n  const direction = Direction(0)\n  let speed = baseSpeed\n  let mass = baseMass\n\n  function update(): void {\n    velocity.add(acceleration)\n    location.add(velocity)\n    acceleration.multiply(0)\n  }\n\n  function applyForce(v: Vector1D): void {\n    v.divide(mass)\n    acceleration.add(v)\n  }\n\n  function seek(v: Vector1D): ScrollBody {\n    attraction.set(v).subtract(location)\n    const magnitude = attraction.get()\n    const m = map(magnitude, 0, 100, 0, speed)\n    direction.set(attraction)\n    attraction\n      .normalize()\n      .multiply(m)\n      .subtract(velocity)\n    applyForce(attraction)\n    return self\n  }\n\n  function settle(v: Vector1D): boolean {\n    const diff = v.get() - location.get()\n    const diffRounded = roundToTwoDecimals(diff)\n    const hasSettled = !diffRounded\n    if (hasSettled) location.set(v)\n    return hasSettled\n  }\n\n  function useSpeed(n: number): ScrollBody {\n    speed = n\n    return self\n  }\n\n  function useMass(n: number): ScrollBody {\n    mass = n\n    return self\n  }\n\n  function useBaseSpeed(): ScrollBody {\n    return useSpeed(baseSpeed)\n  }\n\n  function useBaseMass(): ScrollBody {\n    return useMass(baseMass)\n  }\n\n  const self: ScrollBody = {\n    direction,\n    seek,\n    settle,\n    update,\n    useBaseMass,\n    useBaseSpeed,\n    useMass,\n    useSpeed,\n  }\n  return self\n}\n","import { Animation } from './animation'\nimport { Limit } from './limit'\nimport { ScrollBody } from './scrollBody'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  limit: Limit\n  location: Vector1D\n  scrollBody: ScrollBody\n  animation: Animation\n}\n\nexport type ScrollBounds = {\n  constrain: (v: Vector1D) => void\n  toggleActive: (active: boolean) => void\n}\n\nexport function ScrollBounds(params: Params): ScrollBounds {\n  const { limit, location, scrollBody, animation } = params\n  const { min, max, reachedMin, reachedMax } = limit\n  const tolerance = 50\n  let disabled = false\n  let timeout = 0\n\n  function shouldConstrain(v: Vector1D): boolean {\n    if (disabled || timeout) return false\n    if (reachedMin(location.get())) return v.get() !== min\n    if (reachedMax(location.get())) return v.get() !== max\n    return false\n  }\n\n  function constrain(v: Vector1D): void {\n    if (!shouldConstrain(v)) return\n\n    timeout = window.setTimeout(() => {\n      const constraint = limit.constrain(v.get())\n      v.set(constraint)\n      scrollBody.useSpeed(10).useMass(3)\n      animation.start()\n      timeout = 0\n    }, tolerance)\n  }\n\n  function toggleActive(active: boolean): void {\n    disabled = !active\n  }\n\n  const self: ScrollBounds = {\n    constrain,\n    toggleActive,\n  }\n  return self\n}\n","import { Alignment } from './alignment'\nimport { Limit } from './limit'\n\nexport type ScrollContainOption = '' | 'trimSnaps' | 'keepSnaps'\n\ntype Params = {\n  contentSize: number\n  viewSize: number\n  alignment: Alignment\n}\n\nexport type ScrollContain = {\n  measure: (scrollSnaps: number[], trim: boolean) => number[]\n}\n\nexport function ScrollContain(params: Params): ScrollContain {\n  const { alignment, contentSize, viewSize } = params\n  const scrollBounds = Limit({ min: -contentSize + viewSize, max: 0 })\n  const alignedWithinView = [alignment.measure(contentSize)]\n  const contentExceedsView = contentSize > viewSize\n\n  function findDuplicates(scrollSnaps: number[]): Limit {\n    const startSnap = scrollSnaps[0]\n    const endSnap = scrollSnaps[scrollSnaps.length - 1]\n    const min = scrollSnaps.lastIndexOf(startSnap) + 1\n    const max = scrollSnaps.indexOf(endSnap)\n    return Limit({ min, max })\n  }\n\n  function measure(scrollSnaps: number[], trim: boolean): number[] {\n    const containedSnaps = scrollSnaps.map(scrollBounds.constrain)\n    const { min, max } = findDuplicates(containedSnaps)\n\n    if (!contentExceedsView) return alignedWithinView\n    if (!trim) return containedSnaps\n    return containedSnaps.slice(min - 1, max + 1)\n  }\n\n  const self: ScrollContain = {\n    measure,\n  }\n  return self\n}\n","import { Limit } from './limit'\nimport { PxToPercent } from './pxToPercent'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  contentSize: number\n  limit: Limit\n  location: Vector1D\n  pxToPercent: PxToPercent\n}\n\nexport type ScrollLooper = {\n  loop: (vectors: Vector1D[], direction: number) => void\n}\n\nexport function ScrollLooper(params: Params): ScrollLooper {\n  const { contentSize, location, limit, pxToPercent } = params\n  const min = limit.min + pxToPercent.measure(0.1)\n  const max = limit.max + pxToPercent.measure(0.1)\n  const { reachedMin, reachedMax } = Limit({ min, max })\n\n  function shouldLoop(direction: number): boolean {\n    if (direction === 1) return reachedMax(location.get())\n    if (direction === -1) return reachedMin(location.get())\n    return false\n  }\n\n  function loop(vectors: Vector1D[], direction: number): void {\n    if (!shouldLoop(direction)) return\n\n    const loopDistance = contentSize * (direction * -1)\n    vectors.forEach(v => v.add(loopDistance))\n  }\n\n  const self: ScrollLooper = {\n    loop,\n  }\n  return self\n}\n","import { Limit } from './limit'\r\n\r\ntype Params = {\r\n  limit: Limit\r\n}\r\n\r\nexport type ScrollProgress = {\r\n  get: (n: number) => number\r\n}\r\n\r\nexport function ScrollProgress(params: Params): ScrollProgress {\r\n  const { max, length: scrollLength } = params.limit\r\n\r\n  function get(n: number): number {\r\n    const currentLocation = n - max\r\n    return currentLocation / -scrollLength\r\n  }\r\n\r\n  const self: ScrollProgress = {\r\n    get,\r\n  }\r\n  return self\r\n}\r\n","import { Counter } from './counter'\nimport { Limit } from './limit'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  index: Counter\n  loop: boolean\n  scrollSnaps: number[]\n  contentSize: number\n  limit: Limit\n  target: Vector1D\n}\n\nexport type Target = {\n  distance: number\n  index: number\n}\n\nexport type ScrollTarget = {\n  byIndex: (target: number, direction: number) => Target\n  byDistance: (force: number, snap: boolean) => Target\n  shortcut: (target: number, direction: number) => number\n}\n\nexport function ScrollTarget(params: Params): ScrollTarget {\n  const { loop, limit, scrollSnaps, contentSize } = params\n  const { reachedMax, reachedAny, removeOffset } = limit\n\n  function minDistance(d1: number, d2: number): number {\n    return Math.abs(d1) < Math.abs(d2) ? d1 : d2\n  }\n\n  function findTargetSnap(target: number): Target {\n    const distance = removeOffset(target)\n    const ascDiffsToSnaps = scrollSnaps\n      .map(scrollSnap => scrollSnap - distance)\n      .map(diffToSnap => shortcut(diffToSnap, 0))\n      .map((diff, i) => ({ diff, index: i }))\n      .sort((d1, d2) => Math.abs(d1.diff) - Math.abs(d2.diff))\n\n    const { index } = ascDiffsToSnaps[0]\n    return { index, distance }\n  }\n\n  function shortcut(target: number, direction: number): number {\n    const t1 = target\n    const t2 = target + contentSize\n    const t3 = target - contentSize\n\n    if (!loop) return t1\n    if (!direction) return minDistance(minDistance(t1, t2), t3)\n\n    const shortest = minDistance(t1, direction === 1 ? t2 : t3)\n    return Math.abs(shortest) * direction\n  }\n\n  function findTargetIndex(target: number, index: number): number {\n    const reachedBound = !loop && reachedAny(target)\n    if (!reachedBound) return index\n\n    const { min, max } = params.index\n    return reachedMax(target) ? min : max\n  }\n\n  function byIndex(index: number, direction: number): Target {\n    const diffToSnap = scrollSnaps[index] - params.target.get()\n    const distance = shortcut(diffToSnap, direction)\n    return { index, distance }\n  }\n\n  function byDistance(distance: number, snap: boolean): Target {\n    const target = params.target.get() + distance\n    const targetSnap = findTargetSnap(target)\n    const index = findTargetIndex(target, targetSnap.index)\n    const reachedBound = !loop && reachedAny(target)\n\n    if (!snap || reachedBound) return { index, distance }\n\n    const diffToSnap = scrollSnaps[index] - targetSnap.distance\n    const snapDistance = distance + shortcut(diffToSnap, 0)\n\n    return { index, distance: snapDistance }\n  }\n\n  const self: ScrollTarget = {\n    byDistance,\n    byIndex,\n    shortcut,\n  }\n  return self\n}\n","import { Axis } from './axis'\nimport { arrayKeys } from './utils'\nimport { SlidesInView } from './slidesInView'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  axis: Axis\n  scrollSnaps: number[]\n  viewSize: number\n  location: Vector1D\n  slideSizes: number[]\n  contentSize: number\n  slidesInView: SlidesInView\n}\n\ntype LoopPoint = {\n  point: number\n  location: number\n  index: number\n  getTarget: () => number\n}\n\ntype LoopEdge = 'start' | 'end'\n\nexport type SlideLooper = {\n  canLoop: () => boolean\n  clear: (slides: HTMLElement[]) => void\n  loop: (slides: HTMLElement[]) => void\n  loopPoints: LoopPoint[]\n}\n\nexport function SlideLooper(params: Params): SlideLooper {\n  const { axis, location: scrollLocation, slidesInView } = params\n  const { contentSize, viewSize, slideSizes, scrollSnaps } = params\n  const ascItems = arrayKeys(slideSizes)\n  const descItems = arrayKeys(slideSizes).reverse()\n  const loopPoints = startPoints().concat(endPoints())\n  const loopStyle = axis.scroll === 'x' ? 'left' : 'top'\n\n  function removeSlideSizes(indexes: number[], from: number): number {\n    return indexes.reduce((a: number, i) => {\n      return a - slideSizes[i]\n    }, from)\n  }\n\n  function slidesInGap(indexes: number[], gap: number): number[] {\n    return indexes.reduce((a: number[], i) => {\n      const remainingGap = removeSlideSizes(a, gap)\n      return remainingGap > 0 ? a.concat([i]) : a\n    }, [])\n  }\n\n  function findLoopPoints(indexes: number[], edge: LoopEdge): LoopPoint[] {\n    const isStartEdge = edge === 'start'\n    const offset = isStartEdge ? -contentSize : contentSize\n    const slideBounds = slidesInView.findSlideBounds(offset)\n\n    return indexes.map(index => {\n      const initial = isStartEdge ? 0 : -contentSize\n      const altered = isStartEdge ? contentSize : 0\n      const bounds = slideBounds.filter(b => b.index === index)[0]\n      const point = bounds[isStartEdge ? 'end' : 'start']\n      const getTarget = (): number =>\n        scrollLocation.get() > point ? initial : altered\n      return { point, getTarget, index, location: -1 }\n    })\n  }\n\n  function startPoints(): LoopPoint[] {\n    const gap = scrollSnaps[0] - 1\n    const indexes = slidesInGap(descItems, gap)\n    return findLoopPoints(indexes, 'end')\n  }\n\n  function endPoints(): LoopPoint[] {\n    const gap = viewSize - scrollSnaps[0] - 1\n    const indexes = slidesInGap(ascItems, gap)\n    return findLoopPoints(indexes, 'start')\n  }\n\n  function canLoop(): boolean {\n    return loopPoints.every(({ index }) => {\n      const otherIndexes = ascItems.filter(i => i !== index)\n      return removeSlideSizes(otherIndexes, viewSize) <= 0\n    })\n  }\n\n  function loop(slides: HTMLElement[]): void {\n    loopPoints.forEach(loopPoint => {\n      const { getTarget, location, index } = loopPoint\n      const target = getTarget()\n      if (target !== location) {\n        slides[index].style[loopStyle] = `${target}%`\n        loopPoint.location = target\n      }\n    })\n  }\n\n  function clear(slides: HTMLElement[]): void {\n    loopPoints.forEach(({ index }) => {\n      slides[index].style[loopStyle] = ''\n    })\n  }\n\n  const self: SlideLooper = {\n    canLoop,\n    clear,\n    loop,\n    loopPoints,\n  }\n  return self\n}\n","import { EventStore } from './eventStore'\nimport { ScrollTo } from './scrollTo'\n\ntype Params = {\n  root: HTMLElement\n  scrollTo: ScrollTo\n  slidesToScroll: number\n}\n\nexport type SlideFocus = {\n  addActivationEvents: (slides: HTMLElement[]) => void\n  removeAllEvents: EventStore['removeAll']\n}\n\nexport function SlideFocus(params: Params): SlideFocus {\n  const { scrollTo, slidesToScroll, root } = params\n  const eventStore = EventStore()\n  const removeAllEvents = eventStore.removeAll\n  let lastTabPressTime = 0\n\n  function registerTabPress(event: Event): void {\n    if ((event as KeyboardEvent).keyCode !== 9) return\n    lastTabPressTime = new Date().getTime()\n  }\n\n  function addFocusEvent(slide: HTMLElement, index: number): void {\n    const focus = (): void => {\n      const nowTime = new Date().getTime()\n      const diffTime = nowTime - lastTabPressTime\n      if (diffTime > 10) return\n\n      root.scrollLeft = 0\n      const selectedIndex = Math.floor(index / slidesToScroll)\n      scrollTo.index(selectedIndex, 0)\n    }\n    eventStore.add(slide, 'focus', focus, true)\n  }\n\n  function addActivationEvents(slides: HTMLElement[]): void {\n    eventStore.add(document, 'keydown', registerTabPress, false)\n    slides.forEach(addFocusEvent)\n  }\n\n  const self: SlideFocus = {\n    addActivationEvents,\n    removeAllEvents,\n  }\n  return self\n}\n","import { Axis } from './axis'\nimport { roundToDecimals } from './utils'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  axis: Axis\n  container: HTMLElement\n}\n\nexport type Translate = {\n  clear: () => void\n  to: (vector: Vector1D) => void\n  toggleActive: (active: boolean) => void\n}\n\nexport function Translate(params: Params): Translate {\n  const { axis, container } = params\n  const translates = { x, y }\n  const translateAxis = translates[axis.scroll]\n  const roundToTwoDecimals = roundToDecimals(2)\n  const containerStyle = container.style\n  let disabled = false\n  let location = 0\n\n  function x(n: number): string {\n    return `translate3d(${n}%,0px,0px)`\n  }\n\n  function y(n: number): string {\n    return `translate3d(0px,${n}%,0px)`\n  }\n\n  function to(v: Vector1D): void {\n    if (disabled) return\n    const target = roundToTwoDecimals(v.get())\n\n    if (location !== target) {\n      getComputedStyle(container).transform\n      containerStyle.transform = translateAxis(target)\n      location = target\n    }\n  }\n\n  function toggleActive(active: boolean): void {\n    disabled = !active\n  }\n\n  function clear(): void {\n    containerStyle.transform = ''\n    location = 0\n  }\n\n  const self: Translate = {\n    clear,\n    to,\n    toggleActive,\n  }\n  return self\n}\n","import { Alignment } from './alignment'\nimport { Animation } from './animation'\nimport { Axis } from './axis'\nimport { Counter } from './counter'\nimport { DragHandler } from './dragHandler'\nimport { DragTracker } from './dragTracker'\nimport { EventEmitter } from './eventEmitter'\nimport { Limit } from './limit'\nimport { Options } from './options'\nimport { PxToPercent } from './pxToPercent'\nimport { ScrollBody } from './scrollBody'\nimport { ScrollBounds } from './scrollBounds'\nimport { ScrollContain } from './scrollContain'\nimport { ScrollLimit } from './scrollLimit'\nimport { ScrollLooper } from './scrollLooper'\nimport { ScrollProgress } from './scrollProgress'\nimport { ScrollSnap } from './scrollSnap'\nimport { ScrollTarget } from './scrollTarget'\nimport { ScrollTo } from './scrollTo'\nimport { SlideLooper } from './slideLooper'\nimport { SlideFocus } from './slideFocus'\nimport { SlidesInView } from './slidesInView'\nimport { Translate } from './translate'\nimport { arrayKeys, groupArray } from './utils'\nimport { Vector1D } from './vector1d'\n\nexport type Engine = {\n  axis: Axis\n  animation: Animation\n  scrollBounds: ScrollBounds\n  scrollLooper: ScrollLooper\n  scrollProgress: ScrollProgress\n  index: Counter\n  indexPrevious: Counter\n  limit: Limit\n  location: Vector1D\n  options: Options\n  pxToPercent: PxToPercent\n  scrollBody: ScrollBody\n  dragHandler: DragHandler\n  slideFocus: SlideFocus\n  slideLooper: SlideLooper\n  slidesInView: SlidesInView\n  target: Vector1D\n  translate: Translate\n  scrollTo: ScrollTo\n  scrollTarget: ScrollTarget\n  scrollSnaps: number[]\n  slideIndexes: number[]\n}\n\nexport function Engine(\n  root: HTMLElement,\n  container: HTMLElement,\n  slides: HTMLElement[],\n  options: Options,\n  events: EventEmitter,\n): Engine {\n  // Options\n  const {\n    align,\n    axis: scrollAxis,\n    startIndex,\n    inViewThreshold,\n    loop,\n    speed,\n    dragFree,\n    slidesToScroll,\n    containScroll,\n  } = options\n\n  // Measurements\n  const axis = Axis(scrollAxis)\n  const pxToPercent = PxToPercent(axis.measure(container))\n  const viewSize = pxToPercent.totalPercent\n  const slideSizes = slides.map(axis.measure).map(pxToPercent.measure)\n  const slideIndexes = arrayKeys(slideSizes)\n  const groupedSizes = groupArray(slideSizes, slidesToScroll)\n  const snapSizes = groupedSizes.map(g => g.reduce((a, s) => a + s))\n  const contentSize = slideSizes.reduce((a, s) => a + s, 0)\n  const alignment = Alignment({ align, viewSize })\n  const scrollSnap = ScrollSnap({ snapSizes, alignment, loop })\n  const defaultSnaps = arrayKeys(snapSizes).map(scrollSnap.measure)\n  const contain = ScrollContain({ alignment, contentSize, viewSize })\n  const shouldContain = !loop && containScroll !== ''\n  const trimSnaps = containScroll === 'trimSnaps'\n  const containedSnaps = contain.measure(defaultSnaps, trimSnaps)\n  const scrollSnaps = shouldContain ? containedSnaps : defaultSnaps\n\n  // Index\n  const indexMax = Math.max(0, scrollSnaps.length - 1)\n  const indexSpan = Limit({ min: 0, max: indexMax })\n  const index = Counter({ limit: indexSpan, start: startIndex, loop })\n  const indexPrevious = index.clone()\n\n  // ScrollLimit\n  const scrollLimit = ScrollLimit({ loop, contentSize })\n  const limit = scrollLimit.measure(scrollSnaps)\n\n  // Draw\n  const update = (): void => {\n    engine.scrollBody.seek(target).update()\n    const settled = engine.scrollBody.settle(target)\n\n    if (!dragHandler.pointerDown()) {\n      if (!loop) engine.scrollBounds.constrain(target)\n      if (settled) {\n        engine.animation.stop()\n        events.emit('settle')\n      }\n    }\n    if (loop) {\n      const direction = engine.scrollBody.direction.get()\n      engine.scrollLooper.loop(loopVectors, direction)\n      engine.slideLooper.loop(slides)\n    }\n\n    if (!settled) events.emit('scroll')\n    engine.translate.to(location)\n    engine.animation.proceed()\n  }\n\n  // Shared\n  const animation = Animation(update)\n  const startLocation = scrollSnaps[index.get()]\n  const location = Vector1D(startLocation)\n  const target = Vector1D(startLocation)\n  const loopVectors = [location, target]\n  const scrollBody = ScrollBody({\n    location,\n    speed,\n    mass: 1,\n  })\n  const scrollTarget = ScrollTarget({\n    contentSize,\n    index,\n    limit,\n    loop,\n    scrollSnaps,\n    target,\n  })\n  const scrollTo = ScrollTo({\n    animation,\n    events,\n    index,\n    indexPrevious,\n    scrollTarget,\n    target,\n  })\n  const slidesInView = SlidesInView({\n    contentSize,\n    inViewThreshold,\n    loop,\n    slideSizes,\n    viewSize,\n  })\n\n  // DragHandler\n  const dragHandler = DragHandler({\n    animation,\n    axis,\n    dragFree,\n    dragTracker: DragTracker({\n      axis,\n      pxToPercent,\n    }),\n    element: root,\n    events,\n    index,\n    limit,\n    location,\n    loop,\n    scrollBody,\n    scrollTo,\n    scrollTarget,\n    target,\n  })\n\n  // Slider\n  const engine: Engine = {\n    animation,\n    axis,\n    dragHandler,\n    pxToPercent,\n    index,\n    indexPrevious,\n    limit,\n    location,\n    options,\n    scrollBody,\n    scrollBounds: ScrollBounds({\n      animation,\n      limit,\n      location,\n      scrollBody,\n    }),\n    scrollLooper: ScrollLooper({\n      contentSize,\n      limit,\n      location,\n      pxToPercent,\n    }),\n    scrollProgress: ScrollProgress({\n      limit,\n    }),\n    scrollSnaps,\n    scrollTarget,\n    scrollTo,\n    slideFocus: SlideFocus({\n      root,\n      scrollTo,\n      slidesToScroll,\n    }),\n    slideLooper: SlideLooper({\n      axis,\n      contentSize,\n      location,\n      scrollSnaps,\n      slideSizes,\n      slidesInView,\n      viewSize,\n    }),\n    slidesInView,\n    slideIndexes,\n    target,\n    translate: Translate({\n      axis,\n      container,\n    }),\n  }\n  return engine\n}\n","export type PxToPercent = {\n  measure: (n: number) => number\n  totalPercent: number\n}\n\nexport function PxToPercent(viewInPx: number): PxToPercent {\n  const totalPercent = 100\n\n  function measure(n: number): number {\n    return (n / viewInPx) * totalPercent\n  }\n\n  const self: PxToPercent = {\n    measure,\n    totalPercent,\n  }\n  return self\n}\n","export type AxisOption = 'x' | 'y'\n\nexport type Axis = {\n  cross: AxisOption\n  scroll: AxisOption\n  measure: (node: HTMLElement) => number\n}\n\nexport function Axis(axis: AxisOption): Axis {\n  const scroll = axis === 'y' ? 'y' : 'x'\n  const cross = axis === 'y' ? 'x' : 'y'\n\n  function measure(node: HTMLElement): number {\n    const { width, height } = node.getBoundingClientRect()\n    return scroll === 'x' ? width : height\n  }\n\n  const self: Axis = {\n    cross,\n    measure,\n    scroll,\n  }\n  return self\n}\n","import { Alignment } from './alignment'\nimport { Counter } from './counter'\nimport { Limit } from './limit'\n\ntype Params = {\n  snapSizes: number[]\n  alignment: Alignment\n  loop: boolean\n}\n\nexport type ScrollSnap = {\n  measure: (index: number) => number\n}\n\nexport function ScrollSnap(params: Params): ScrollSnap {\n  const { snapSizes, alignment, loop } = params\n  const alignments = snapSizes.map(alignment.measure)\n  const distancesBetween = distancesBetweenScrollSnaps()\n\n  function distancesBetweenScrollSnaps(): number[] {\n    const limit = Limit({ min: 0, max: snapSizes.length - 1 })\n    const counter = Counter({ limit, start: 0, loop })\n\n    return snapSizes.map((size, index) => {\n      const next = counter.set(index + 1).get()\n      return size + alignments[index] - alignments[next]\n    })\n  }\n\n  function measure(index: number): number {\n    const sizes = distancesBetween.slice(0, index)\n    return sizes.reduce((a, s) => a - s, alignments[0])\n  }\n\n  const self: ScrollSnap = {\n    measure,\n  }\n  return self\n}\n","import { Limit } from './limit'\n\ntype Params = {\n  contentSize: number\n  loop: boolean\n}\n\nexport type ScrollLimit = {\n  measure: (scrollSnaps: number[]) => Limit\n}\n\nexport function ScrollLimit(params: Params): ScrollLimit {\n  const { contentSize, loop } = params\n\n  function measure(scrollSnaps: number[]): Limit {\n    const startSnap = scrollSnaps[0]\n    const endSnap = scrollSnaps[scrollSnaps.length - 1]\n    const min = loop ? startSnap - contentSize : endSnap\n    const max = startSnap\n    return Limit({ min, max })\n  }\n\n  const self: ScrollLimit = {\n    measure,\n  }\n  return self\n}\n","type Callback = () => void\n\nexport type Animation = {\n  start: () => void\n  stop: () => void\n  proceed: () => void\n}\n\nexport function Animation(callback: FrameRequestCallback): Animation {\n  let animationFrame = 0\n\n  function ifAnimating(active: boolean, cb: Callback): Callback {\n    return (): void => {\n      if (active === !!animationFrame) cb()\n    }\n  }\n\n  function start(): void {\n    animationFrame = window.requestAnimationFrame(callback)\n  }\n\n  function stop(): void {\n    window.cancelAnimationFrame(animationFrame)\n    animationFrame = 0\n  }\n\n  const self: Animation = {\n    proceed: ifAnimating(true, start),\n    start: ifAnimating(false, start),\n    stop: ifAnimating(true, stop),\n  }\n  return self\n}\n","import { Animation } from './animation'\nimport { Counter } from './counter'\nimport { EventEmitter } from './eventEmitter'\nimport { ScrollTarget, Target } from './scrollTarget'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  animation: Animation\n  target: Vector1D\n  index: Counter\n  indexPrevious: Counter\n  scrollTarget: ScrollTarget\n  events: EventEmitter\n}\n\nexport type ScrollTo = {\n  distance: (n: number, snap: boolean) => void\n  index: (n: number, direction: number) => void\n}\n\nexport function ScrollTo(params: Params): ScrollTo {\n  const { index: indexCurrent, scrollTarget, animation } = params\n  const { indexPrevious, events, target: targetDistance } = params\n\n  function scrollTo(target: Target): void {\n    const distanceDiff = target.distance\n    const indexDiff = target.index !== indexCurrent.get()\n\n    if (distanceDiff) {\n      animation.start()\n      targetDistance.add(distanceDiff)\n    }\n    if (indexDiff) {\n      indexPrevious.set(indexCurrent.get())\n      indexCurrent.set(target.index)\n      events.emit('select')\n    }\n  }\n\n  function distance(n: number, snap: boolean): void {\n    const target = scrollTarget.byDistance(n, snap)\n    scrollTo(target)\n  }\n\n  function index(n: number, direction: number): void {\n    const targetIndex = indexCurrent.clone().set(n)\n    const target = scrollTarget.byIndex(targetIndex.get(), direction)\n    scrollTo(target)\n  }\n\n  const self: ScrollTo = {\n    distance,\n    index,\n  }\n  return self\n}\n","import { arrayKeys } from './utils'\n\ntype Params = {\n  contentSize: number\n  slideSizes: number[]\n  viewSize: number\n  loop: boolean\n  inViewThreshold: number\n}\n\ntype SlideBound = {\n  start: number\n  end: number\n  index: number\n}\n\nexport type SlidesInView = {\n  check: (location: number) => number[]\n  findSlideBounds: (offset: number, threshold?: number) => SlideBound[]\n}\n\nexport function SlidesInView(params: Params): SlidesInView {\n  const { contentSize, slideSizes, viewSize } = params\n  const { inViewThreshold, loop } = params\n  const threshold = Math.min(Math.max(inViewThreshold, 0.01), 0.99)\n  const scrollSnaps = arrayKeys(slideSizes).map(scrollSnap)\n  const offsets = loop ? [0, contentSize, -contentSize] : [0]\n  const slideBounds = offsets.reduce((a: SlideBound[], loopOffset) => {\n    return a.concat(findSlideBounds(loopOffset, threshold))\n  }, [])\n\n  function scrollSnap(index: number): number {\n    const span = slideSizes.slice(0, index)\n    return span.reduce((a, s) => a - s, 0)\n  }\n\n  function findSlideBounds(offset: number, threshold?: number): SlideBound[] {\n    const thresholds = slideSizes.map(s => s * (threshold || 0))\n    return scrollSnaps.map((snap, index) => ({\n      start: snap - slideSizes[index] + thresholds[index] + offset,\n      end: snap + viewSize - thresholds[index] + offset,\n      index,\n    }))\n  }\n\n  function check(location: number): number[] {\n    return slideBounds.reduce((list: number[], slideBound) => {\n      const { index, start, end } = slideBound\n      const inList = list.indexOf(index) !== -1\n      const inView = start < location && end > location\n      return !inList && inView ? list.concat([index]) : list\n    }, [])\n  }\n\n  const self: SlidesInView = {\n    check,\n    findSlideBounds,\n  }\n  return self\n}\n","import { AlignmentOption } from './alignment'\nimport { AxisOption } from './axis'\nimport { ScrollContainOption } from './scrollContain'\n\nexport type Options = {\n  align: AlignmentOption\n  axis: AxisOption\n  containScroll: ScrollContainOption\n  containerSelector: string\n  dragFree: boolean\n  draggable: boolean\n  draggableClass: string\n  draggingClass: string\n  inViewThreshold: number\n  loop: boolean\n  selectedClass: string\n  slidesToScroll: number\n  speed: number\n  startIndex: number\n}\n\nexport const defaultOptions: Options = {\n  align: 'center',\n  axis: 'x',\n  containScroll: '',\n  containerSelector: '*',\n  dragFree: false,\n  draggable: true,\n  draggableClass: 'is-draggable',\n  draggingClass: 'is-dragging',\n  inViewThreshold: 0,\n  loop: false,\n  selectedClass: 'is-selected',\n  slidesToScroll: 1,\n  speed: 10,\n  startIndex: 0,\n}\n\nexport type EmblaOptions = Partial<Options>\n","import { Engine } from './components/engine'\nimport { EventEmitter, EmblaEvent } from './components/eventEmitter'\nimport { EventStore } from './components/eventStore'\nimport { defaultOptions, EmblaOptions } from './components/options'\nimport {\n  addClass,\n  arrayFromCollection,\n  debounce,\n  removeClass,\n} from './components/utils'\n\nexport type EmblaCarousel = {\n  canScrollNext: () => boolean\n  canScrollPrev: () => boolean\n  clickAllowed: () => boolean\n  containerNode: () => HTMLElement\n  dangerouslyGetEngine: () => Engine\n  destroy: () => void\n  off: EventEmitter['off']\n  on: EventEmitter['on']\n  previousScrollSnap: () => number\n  reInit: (options?: EmblaOptions) => void\n  scrollNext: () => void\n  scrollPrev: () => void\n  scrollProgress: () => number\n  scrollSnapList: () => number[]\n  scrollTo: (index: number) => void\n  selectedScrollSnap: () => number\n  slideNodes: () => HTMLElement[]\n  slidesInView: (target?: boolean) => number[]\n  slidesNotInView: (target?: boolean) => number[]\n}\n\nfunction EmblaCarousel(\n  sliderRoot: HTMLElement,\n  userOptions?: EmblaOptions,\n): EmblaCarousel {\n  const events = EventEmitter()\n  const eventStore = EventStore()\n  const debouncedResize = debounce(resize, 500)\n  const reInit = reActivate\n  const { on, off } = events\n\n  let engine: Engine\n  let activated = false\n  let options = Object.assign({}, defaultOptions)\n  let rootElementSize = 0\n  let container: HTMLElement\n  let slides: HTMLElement[]\n\n  activate(userOptions)\n\n  function storeElements(): void {\n    if (!sliderRoot) throw new Error('Missing root node ')\n\n    const selector = options.containerSelector\n    const sliderContainer = sliderRoot.querySelector(selector)\n\n    if (!sliderContainer) throw new Error('Missing container node ')\n\n    container = sliderContainer as HTMLElement\n    slides = arrayFromCollection(container.children)\n  }\n\n  function activate(partialOptions?: EmblaOptions): void {\n    storeElements()\n    options = Object.assign(options, partialOptions)\n    engine = Engine(sliderRoot, container, slides, options, events)\n    rootElementSize = engine.axis.measure(sliderRoot)\n    eventStore.add(window, 'resize', debouncedResize)\n    engine.translate.to(engine.location)\n\n    if (options.loop) {\n      if (!engine.slideLooper.canLoop()) {\n        deActivate()\n        return activate({ loop: false })\n      }\n      engine.slideLooper.loop(slides)\n    }\n    if (options.draggable && slides.length) {\n      engine.dragHandler.addActivationEvents()\n      if (options.draggableClass) {\n        addClass(sliderRoot, options.draggableClass)\n      }\n      if (options.draggingClass) {\n        events\n          .on('pointerDown', toggleDraggingClass)\n          .on('pointerUp', toggleDraggingClass)\n      }\n    }\n    if (slides.length) {\n      engine.slideFocus.addActivationEvents(slides)\n    }\n    if (options.selectedClass) {\n      toggleSelectedClass()\n      events\n        .on('select', toggleSelectedClass)\n        .on('pointerUp', toggleSelectedClass)\n    }\n    if (!activated) {\n      setTimeout(() => events.emit('init'), 0)\n      activated = true\n    }\n  }\n\n  function toggleDraggingClass(evt: EmblaEvent): void {\n    const { draggingClass } = options\n    if (evt === 'pointerDown') addClass(sliderRoot, draggingClass)\n    else removeClass(sliderRoot, draggingClass)\n  }\n\n  function toggleSelectedClass(): void {\n    const { selectedClass } = options\n    const inView = slidesInView(true)\n    const notInView = slidesNotInView(true)\n    notInView.forEach(i => removeClass(slides[i], selectedClass))\n    inView.forEach(i => addClass(slides[i], selectedClass))\n  }\n\n  function deActivate(): void {\n    engine.dragHandler.removeAllEvents()\n    engine.slideFocus.removeAllEvents()\n    engine.animation.stop()\n    eventStore.removeAll()\n    engine.translate.clear()\n    engine.slideLooper.clear(slides)\n    removeClass(sliderRoot, options.draggableClass)\n    slides.forEach(s => removeClass(s, options.selectedClass))\n    events.off('select', toggleSelectedClass)\n    events.off('pointerUp', toggleSelectedClass)\n    events.off('pointerDown', toggleDraggingClass)\n    events.off('pointerUp', toggleDraggingClass)\n  }\n\n  function reActivate(partialOptions?: EmblaOptions): void {\n    if (!activated) return\n    const startIndex = selectedScrollSnap()\n    const newOptions = Object.assign({ startIndex }, partialOptions)\n    deActivate()\n    activate(newOptions)\n    events.emit('reInit')\n  }\n\n  function destroy(): void {\n    if (!activated) return\n    deActivate()\n    activated = false\n    events.emit('destroy')\n  }\n\n  function resize(): void {\n    if (!activated) return\n    const newRootElementSize = engine.axis.measure(sliderRoot)\n    if (rootElementSize !== newRootElementSize) reActivate()\n    events.emit('resize')\n  }\n\n  function slidesInView(target?: boolean): number[] {\n    const location = engine[target ? 'target' : 'location'].get()\n    const type = options.loop ? 'removeOffset' : 'constrain'\n    return engine.slidesInView.check(engine.limit[type](location))\n  }\n\n  function slidesNotInView(target?: boolean): number[] {\n    const inView = slidesInView(target)\n    return engine.slideIndexes.filter(i => inView.indexOf(i) === -1)\n  }\n\n  function scrollTo(index: number, direction?: number): void {\n    engine.scrollBody.useBaseMass().useBaseSpeed()\n    if (activated) engine.scrollTo.index(index, direction || 0)\n  }\n\n  function scrollNext(): void {\n    const next = engine.index.clone().add(1)\n    scrollTo(next.get(), -1)\n  }\n\n  function scrollPrev(): void {\n    const prev = engine.index.clone().add(-1)\n    scrollTo(prev.get(), 1)\n  }\n\n  function canScrollNext(): boolean {\n    const next = engine.index.clone().add(1)\n    return next.get() !== selectedScrollSnap()\n  }\n\n  function canScrollPrev(): boolean {\n    const prev = engine.index.clone().add(-1)\n    return prev.get() !== selectedScrollSnap()\n  }\n\n  function scrollSnapList(): number[] {\n    return engine.scrollSnaps.map(engine.scrollProgress.get)\n  }\n\n  function scrollProgress(): number {\n    return engine.scrollProgress.get(engine.location.get())\n  }\n\n  function selectedScrollSnap(): number {\n    return engine.index.get()\n  }\n\n  function previousScrollSnap(): number {\n    return engine.indexPrevious.get()\n  }\n\n  function clickAllowed(): boolean {\n    return engine.dragHandler.clickAllowed()\n  }\n\n  function dangerouslyGetEngine(): Engine {\n    return engine\n  }\n\n  function containerNode(): HTMLElement {\n    return container\n  }\n\n  function slideNodes(): HTMLElement[] {\n    return slides\n  }\n\n  const self: EmblaCarousel = {\n    canScrollNext,\n    canScrollPrev,\n    clickAllowed,\n    containerNode,\n    dangerouslyGetEngine,\n    destroy,\n    off,\n    on,\n    previousScrollSnap,\n    reInit,\n    scrollNext,\n    scrollPrev,\n    scrollProgress,\n    scrollSnapList,\n    scrollTo,\n    selectedScrollSnap,\n    slideNodes,\n    slidesInView,\n    slidesNotInView,\n  }\n  return self\n}\n\nexport default EmblaCarousel\n","type Callback = (evt: EmblaEvent) => void\ntype Listeners = { [key in EmblaEvent]: Callback[] }\n\nexport type EmblaEvent =\n  | 'init'\n  | 'pointerDown'\n  | 'pointerUp'\n  | 'scroll'\n  | 'select'\n  | 'settle'\n  | 'destroy'\n  | 'reInit'\n  | 'resize'\n\nexport type EventEmitter = {\n  emit: (evt: EmblaEvent) => EventEmitter\n  on: (evt: EmblaEvent, cb: Callback) => EventEmitter\n  off: (evt: EmblaEvent, cb: Callback) => EventEmitter\n}\n\nexport function EventEmitter(): EventEmitter {\n  const listeners: Listeners = {\n    destroy: [],\n    pointerDown: [],\n    pointerUp: [],\n    init: [],\n    reInit: [],\n    resize: [],\n    scroll: [],\n    select: [],\n    settle: [],\n  }\n\n  function emit(evt: EmblaEvent): EventEmitter {\n    listeners[evt].forEach(e => e(evt))\n    return self\n  }\n\n  function on(evt: EmblaEvent, cb: Callback): EventEmitter {\n    listeners[evt] = listeners[evt].concat([cb])\n    return self\n  }\n\n  function off(evt: EmblaEvent, cb: Callback): EventEmitter {\n    listeners[evt] = listeners[evt].filter(e => e !== cb)\n    return self\n  }\n\n  const self: EventEmitter = {\n    emit,\n    off,\n    on,\n  }\n  return self\n}\n","import { useRef, useEffect, useState, useMemo } from 'react'\nimport Carousel, { EmblaCarousel } from '../vanilla'\nimport { EmblaOptions } from '../vanilla/components/options'\nimport { areEqualShallow, canUseDOM } from './utils'\n\ntype ViewportRef = <ViewportElement extends HTMLElement>(\n  instance: ViewportElement | null,\n) => void\n\nexport type UseEmblaCarousel = [ViewportRef, EmblaCarousel | undefined]\n\nfunction useEmblaCarousel(options: EmblaOptions = {}): UseEmblaCarousel {\n  const [embla, setEmbla] = useState<EmblaCarousel>()\n  const [viewport, setViewport] = useState<HTMLElement>()\n  const storedOptions = useRef<EmblaOptions>(options)\n  const activeOptions = useMemo<EmblaOptions>(() => {\n    if (!areEqualShallow(storedOptions.current, options)) {\n      storedOptions.current = options\n    }\n    return storedOptions.current\n  }, [storedOptions, options])\n\n  useEffect(() => {\n    if (canUseDOM() && viewport) {\n      const newEmbla = Carousel(viewport, activeOptions)\n      setEmbla(newEmbla)\n      return () => newEmbla.destroy()\n    } else {\n      setEmbla(undefined)\n    }\n  }, [viewport, activeOptions, setEmbla])\n\n  return [setViewport as ViewportRef, embla]\n}\n\nexport { useEmblaCarousel }\n","export function canUseDOM(): boolean {\n  return !!(\n    typeof window !== 'undefined' &&\n    window.document &&\n    window.document.createElement\n  )\n}\n\nexport function areEqualShallow(\n  objectA: { [key: string]: any },\n  objectB: { [key: string]: any },\n): boolean {\n  return (\n    Object.keys(objectA).length === Object.keys(objectB).length &&\n    Object.keys(objectA).every(objectKey => {\n      if (!objectB.hasOwnProperty(objectKey)) return false\n      return objectA[objectKey] === objectB[objectKey]\n    })\n  )\n}\n"],"sourceRoot":""}